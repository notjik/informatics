from functools import lru_cache
from itertools import product, permutations

'''
2. (И. Женецкий) Логическая функция F задаётся выражением (y → z) ∧ ¬(z ∧ x). На рисунке приведён частично заполненный 
фрагмент таблицы истинности функции F, содержащий неповторяющиеся строки. Определите, какому столбцу таблицы истинности 
функции F соответствует каждая из переменных x, y, z. 
В ответе напишите буквы x, y, z в том порядке, в котором идут соответствующие им столбцы. Буквы в ответе пишите подряд, 
никаких разделителей между буквами ставить не нужно.
'''
# print('x y z f')
# for x, y, z in product([0, 1], repeat=3):
#     f = int((not y or z) and not (z and x))
#     if f:
#         print(x, y, z, f)


'''
5. (Е. Джобс) Автомат обрабатывает десятичное натуральное число N по следующему алгоритму:
1) Строится двоично-десятичное представление: каждый разряд десятичного числа кодируется с
помощью 4 битов, затем полученные коды записываются друг за другом с сохранением незначащих
нулей.
2) Полученная двоичная последовательность инвертируется – все нули меняются на единицы, а все
единицы на нули.
3) Полученное в результате этих операций число переводится в десятичную систему счисления.
Пример. Дано число 13. Оно преобразуется следующим образом:
13 → 00010011ДД → 111011002 → 236.
Здесь нижний индекс «ДД» обозначает двоично-десятичную систему. Укажите число N, в результате
обработки которого с помощью этого алгоритма получается число 151.
'''
# def dd4(n: int) -> str:
#     res = ''
#     for i in str(n):
#         res += bin(int(i))[2::].zfill(4)
#     return res
#
#
# def invert(s: str) -> str:
#     return s.replace('1', '2').replace('0', '1').replace('2', '0')
#
#
# for n in range(1, 100):
#     r = invert(dd4(n))
#     if int(r, 2) == 151:
#         print(n, r, int(r, 2))

'''
8. Вася составляет слова из букв слова ШАРЛАТАН. Код должен состоять из 8 букв, и каждая буква в
нём должна встречаться столько же раз, сколько в заданном слове. Кроме того, в коде должны стоять
рядом две гласные или две согласные буквы. Сколько различных слов может составить Вася?
'''
# c = 0
# for s in set(permutations('ШАРЛАТАН')):
#     s = ''.join(s)
#     for i in range(len(s) - 1):
#         if s[i] in 'ШРЛТН' and s[i+1] in 'ШРЛТН' or s[i] == 'А' and s[i+1] == 'А':
#             c += 1
#             break
# print(c)


'''
12. Исполнитель Редактор получает на вход строку цифр и преобразовывает её. Редактор может
выполнять две команды, в обеих командах v и w обозначают цепочки цифр.
1. заменить (v, w)
2. нашлось (v)
Первая команда заменяет в строке первое слева вхождение цепочки v на цепочку w, вторая проверяет,
встречается ли цепочка v в строке исполнителя Редактор. Если она встречается, то команда
возвращает логическое значение «истина», в противном случае возвращает значение «ложь».
Какая строка получится в результате применения приведённой ниже программы к строке, состоящей
из 21 цифры, причем первые девять цифр – четверки, а остальные – пятерки? В ответе запишите
полученную строку.
НАЧАЛО
ПОКА нашлось (444) ИЛИ нашлось (888)
 ЕСЛИ нашлось (444)
 ТО заменить (444, 8)
 КОНЕЦ ЕСЛИ
 ПОКА нашлось (555)
 заменить (555, 8)
 КОНЕЦ ПОКА
 ПОКА нашлось (888)
 заменить (888, 3)
 КОНЕЦ ПОКА
КОНЕЦ ПОКА
КОНЕЦ
'''
# s = '4' * 9 + '5' * (21-9)
# while '444' in s or '888' in s:
#     if '444' in s:
#         s = s.replace('444', '8', 1)
#     while '555' in s:
#         s = s.replace('555', '8')
#     while '888' in s:
#         s = s.replace('888', '3')
# print(s)


'''
14. Решите уравнение 101x + 13 = 101x+1. Ответ запишите в десятичной системе счисления.
'''
# for x in range(2, 9):
#     if int('101', x) + 13 == int('101', x + 1):
#         print(x)


'''
15. (М.В. Кузнецова) Введём выражение M & K, обозначающее поразрядную конъюнкцию M и K
(логическое «И» между соответствующими битами двоичной записи). Определите наименьшее
натуральное число A, такое что выражение
( (X & 13 ≠ 0) ∧ (X & 39 ≠ 0)) → ((X & A ≠ 0) ∧ (X & 13 ≠ 0))
тождественно истинно (то есть принимает значение 1 при любом натуральном значении переменной
X)?
'''
# for a in range(1, 500):
#     flag = True
#     for x in range(1, 500):
#         if not(not((x & 13 != 0) and (x & 39 != 0)) or ((x & a != 0) and (x & 13 != 0))):
#             flag = False
#             break
#     if flag:
#         print(a)
#         break


'''
16. Алгоритм вычисления значения функции F(n), где n – натуральное число, задан следующими
соотношениями:
F(n) = n, при n ≤ 3
при n > 3:
 F(n) = n + F(n–1), при чётном n;
 F(n) = n*n + F(n-2), при нечётном n;
Определите количество натуральных значений n, при которых F(n) меньше, чем 108.
'''
# def f(n):
#     if n <= 3:
#         return n
#     return n + f(n - 1) if not (n % 2) else n * n + f(n - 2)
#
#
# c = 0
# for i in range(1, 1000):
#     if f(i) < 10 ** 8:
#         c += 1
# print(c)


'''
17. В файле 17-1.txt содержится последовательность целых чисел. Элементы последовательности
могут принимать целые значения от –10 000 до 10 000 включительно. Определите количество пар, в
которых хотя бы один из двух элементов больше, чем среднее арифметическое всех чисел в файле, и
хотя бы один из двух элементов оканчивается на 3. В ответе запишите два числа: сначала количество
найденных пар, а затем – максимальную сумму элементов таких пар. В данной задаче под парой
подразумевается два идущих подряд элемента последовательности.
'''
# with open('data/17-1.txt') as f:
#     data = list(map(int, f.readlines()))
# avg = sum(data) / len(data)
# mxs = -20000
# c = 0
# for i in range(len(data) - 1):
#     if (data[i] > avg or data[i+1] > avg) and (data[i] % 10 == 3 or data[i+1] % 10 == 3):
#         c += 1
#         mxs = max(mxs, data[i] + data[i+1])
# print(c, mxs)


'''
19. Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежат две кучи камней.
Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в одну из куч
один камень или увеличить количество камней в куче в два раза. Чтобы делать ходы, у каждого
игрока есть неограниченное количество камней. Игра завершается в тот момент, когда суммарное
количество камней в кучах становится не менее 77. Победителем считается игрок, сделавший
последний ход, т. е. первым получивший позицию, в которой в кучах будет 77 или больше камней.
В начальный момент в первой куче было 7 камней, во второй куче – S камней, 1 ≤ S ≤ 69. Будем
говорить, что игрок имеет выигрышную стратегию, если он может выиграть при любых ходах
противника.
Ответьте на следующие вопросы:
Вопрос 1. Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети.
Назовите минимальное значение S, при котором это возможно.
Вопрос 2. Найдите два таких значения S, при которых у Пети есть выигрышная стратегия, причём
Петя не может выиграть первым ходом, но может выиграть своим вторым ходом независимо от того,
как будет ходить Ваня. Найденные значения запишите в ответе в порядке возрастания.
Вопрос 3. Укажите минимальное значение S, при котором у Вани есть выигрышная стратегия,
позволяющая ему выиграть первым или вторым ходом при любой игре Пети, и при этом у Вани нет
стратегии, которая позволит ему гарантированно выиграть первым ходом.
'''
# @lru_cache(None)
# def game(x, y):
#     if x + y >= 77:
#         return 0
#     tmp = [game(x + 1, y), game(x, y + 1),
#            game(x * 2, y), game(x, y * 2)]
#     negative = [i for i in tmp if i <= 0]
#     if len(negative) != 0:
#         return -max(negative) + 1
#     else:
#         return -max(tmp)
#
#
# print(sorted([i for i in range(1, 70) if game(7, i) == 2]))
# print(min([i for i in range(1, 70) if game(7, i) == -2]))


'''
20. Ниже записана программа. Получив на вход число x, эта программа печатает два числа, L и M.
Укажите наименьшее из таких чисел x, при вводе которых алгоритм печатает сначала 3, а потом 8.
'''
# for i in range(1, 1000):
#     x = i
#     L = 0
#     M = 0
#     while x > 0:
#         L = L + 1
#         if x % 2 == 1:
#             M = M + (x % 10)
#         x = x // 10
#     if L == 3 and M == 8:
#         print(i)
#         break


'''
21. (С.С. Поляков) У исполнителя Калькулятор есть три команды, которым присвоены номера:
1. Прибавить 1
2. Прибавить 5
3. Умножить на 3
Сколько разных чисел может быть получено из числа 1 с помощью программ, состоящих из 7 команд?
'''
# l = [1]
# i = 0
# while i != 7:
#     for j in range(len(l)):
#         x = l.pop(0)
#         l += [x + 1, x + 5, x * 3]
#     i += 1
# print(len(set(l)))


'''
22. Текстовый файл 24-181.txt содержит строку из заглавных латинских букв и точек, всего не более
106 символов. Определите максимальное количество идущих подряд символов, среди которых не
более одной точки.
'''
# with open('data/24-181.txt') as f:
#     s = f.readline()
# c = 0
# mx = 0
# for x in s:
#     c += 1
#     if x == '.':
#         mx = max(mx, c)
#         c = 0
# print(mx)


'''
23. Напишите программу, которая ищет среди целых чисел, принадлежащих числовому отрезку
[5336748; 5336834], простые числа. Выведите все найденные простые числа в порядке возрастания,
слева от каждого числа выведите его номер по порядку.
'''
# def prime(n):
#     for i in range(2, (n // 2) + 1):
#         if n % i == 0:
#             return False
#     return True
#
#
# n = 0
# for i in range(5336748, 5336835):
#     if prime(i):
#         n += 1
#         print(n, i)


'''
24. (Е. Джобс) Системный администратор раз в неделю создаёт архив пользовательских файлов.
Однако объём диска, куда он помещает архив, может быть меньше, чем суммарный объём
архивируемых файлов. Известно, какой объём занимает файл каждого пользователя. Системный
администратор старается сохранить файлы как можно большего размера. При этом используя
выделенную память максимально эффективно – сохраняя файлы меньшего размера, если файлы
большего не могут быть сохранены.
Входные данные. В первой строке входного файла 26-j3.txt находятся два числа: S – размер
свободного места на диске (натуральное число, не превышающее 1000000) и N – количество
пользователей (натуральное число, не превышающее 10000). В следующих N строках находятся
значения объёмов файлов каждого пользователя (все числа натуральные, не превышающие 100),
каждое в отдельной строке. Запишите в ответе два числа: сначала число сохраненных файлов, затем
размер наименьшего сохраненного файла.
Пример входного файла:
100 4
70
10
25
3
При таких исходных данных можно сохранить три файла – 70, 25, 3. Поэтому ответ должен содержать
два числа – 3 и 3.
'''
# with open('data/26-j3.txt') as f:
#     s, n = map(int, f.readline().split())
#     data = list(map(int, f.readlines()))
# data.sort()
# a = []
# i = 0
# flag = True
# while flag:
#     if s - data[i] >= 0:
#         s -= data[i]
#         a.append(data[i])
#     else:
#         flag = False
#     if s - data[len(data)-i-1]:
#         s -= data[len(data)-i-1]
#         a.append(data[len(data)-i-1])
# print(len(a), min(a))


'''
25. Имеется набор данных, состоящий из троек положительных целых чисел. Необходимо выбрать из
каждой тройки два числа так, чтобы сумма всех выбранных чисел делилась на 6 и при этом была
минимально возможной. Гарантируется, что искомую сумму получить можно. Программа должна
напечатать одно число – минимально возможную сумму, соответствующую условиям задачи.
Входные данные. Даны два входных файла (файл A и файл B), каждый из которых содержит в первой
строке количество троек N (1 ≤ N ≤ 100000). Каждая из следующих N строк содержит три
натуральных числа, не превышающих 10 000.
Пример входного файла:
6
8 3 4
4 8 12
9 5 6
2 6 5
12 3 5
1 4 12
Для указанных входных данных значением искомой суммы должно быть число 54.
В ответе укажите два числа: сначала искомое значение для файла А, затем для файла B.
'''
with open('data/27-34a.txt') as f:
    n = int(f.readline())
    data = list(map(lambda x: list(map(int, x.split())), f.readlines()))
summ = 0
lst = 0
for i in data:
    i.sort()
    if not((i[0] + i[1]) % 6):
        summ += i[0] + i[1]
    elif not((i[0] + i[2]) % 6):
        summ += i[0] + i[2]
    elif not((i[1] + i[2]) % 6):
        summ += i[1] + i[2]
    else:
        if lst > 0:
            if not ((i[0] + i[1]) % 2):
                summ += i[0] + i[1]
                lst -= 1
            elif not ((i[0] + i[2]) % 2):
                summ += i[0] + i[2]
                lst -= 1
            elif not ((i[1] + i[2]) % 2):
                summ += i[1] + i[2]
                lst -= 1
            else:
                if sum(map(int, str((i[0] + i[1])))) == 3:
                    summ += i[0] + i[1]
                    lst = 1
                elif sum(map(int, str((i[0] + i[2])))) == 3:
                    summ += i[0] + i[2]
                    lst = 1
                elif sum(map(int, str((i[1] + i[2])))) == 3:
                    summ += i[1] + i[2]
                    lst = 1
        else:
            if sum(map(int, str((i[0] + i[1])))) == 3:
                summ += i[0] + i[1]
                lst = 1
            elif sum(map(int, str((i[0] + i[2])))) == 3:
                summ += i[0] + i[2]
                lst = 1
            elif sum(map(int, str((i[1] + i[2])))) == 3:
                summ += i[1] + i[2]
                lst = 1
            else:
                if not ((i[0] + i[1]) % 2):
                    summ += i[0] + i[1]
                    lst -= 1
                elif not ((i[0] + i[2]) % 2):
                    summ += i[0] + i[2]
                    lst -= 1
                elif not ((i[1] + i[2]) % 2):
                    summ += i[1] + i[2]
                    lst -= 1
print(summ)
