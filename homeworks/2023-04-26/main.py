from functools import lru_cache


def to_base(n, b):
    a = [chr(i) for i in range(48, 58)] + [chr(l) for l in range(ord('a'), ord('z') + 1)]
    r = a[n % b]
    while n >= b:
        n //= b
        r += a[n % b]
    return r[::-1]


"""
1 Исполнитель Редактор получает на вход строку цифр и преобразовывает её. Редактор может выполнять две
команды, в обеих командах v и w обозначают цепочки символов.
1. заменить (v, w)
2. нашлось (v)
Первая команда заменяет в строке первое слева вхождение цепочки v на цепочку w. Если цепочки v в строке
нет, эта команда не изменяет строку. Вторая команда проверяет, встречается ли цепочка v в строке исполнителя
Редактор.
Дана программа для исполнителя Редактор:
ПОКА нашлось (555) ИЛИ нашлось (888)
заменить (555, 8)
заменить (888, 55)
КОНЕЦ ПОКА
Известно, что начальная строка состоит более чем из 300 цифр 5 и не содержит других символов. В ходе
работы алгоритма получилась строка, содержащая больше цифр 5, чем цифр 8. Укажите минимальную
возможную длину входной строки.
"""
# # TODO: Ответ — 303
# for i in range(301, 10000):
#     s = '5' * i
#     while '555' in s or '888' in s:
#         s = s.replace('555', '8', 1)
#         s = s.replace('888', '55', 1)
#     if s.count('5') > s.count('8'):
#         print(i)
#         break


"""
2 (Е. Джобс) Исполнитель Редактор получает на вход строку цифр и преобразовывает её. Редактор может
выполнять две команды, в обеих командах v и w обозначают цепочки символов.
1. заменить (v, w)
2. нашлось (v)
Первая команда заменяет в строке первое слева вхождение цепочки v на цепочку w. Если цепочки v в строке
нет, эта команда не изменяет строку. Вторая команда проверяет, встречается ли цепочка v в строке исполнителя
Редактор.
Дана программа для исполнителя Редактор:
НАЧАЛО
ПОКА нашлось(111) или нашлось(333)
ЕСЛИ нашлось(111)
ТО заменить(111, 3)
ИНАЧЕ заменить(333, 1)
КОНЕЦ ПОКА
КОНЕЦ
На вход программе подана строка из более чем 100 подряд идущих символов «3». Найдите минимальную длину
входной строки, в результате обработки которой получится минимальное возможное число.
"""
# # TODO: Ответ — 107
# res = []
# for i in range(101, 1000):
#     s = '3' * i
#     while '111' in s or '333' in s:
#         if '111' in s:
#             s = s.replace('111', '3', 1)
#         else:
#             s = s.replace('333', '1', 1)
#     res.append((int(s), i))
# print(min(res, key=lambda x: x[0])[1])


"""
3 (Д. Статный) На рисунке – схема дорог, связывающих пункты A, B, C, D, E, F, G, H, I, J, K, L, M. По каждой
из них можно передвигаться только в одном направлении, указанном стрелкой. Определите количество
различных путей ненулевой длины, которые начинаются и заканчиваются в городе E, не содержат этот город в
качестве промежуточного пункта и проходят через промежуточные города не более одного раза.
"""
# # TODO: Ответ — 16


"""
4 На рисунке – схема дорог, связывающих города А, Б, В, Г, Д, Е, Ж, З, И, К, Л, М, Н, O, Т. По каждой дороге
можно двигаться только в одном направлении, указанном стрелкой. Сколько существует различных путей,
ведущих из города А в город Т и проходящих через город К?
"""
# # TODO: Ответ — 144


"""
5 (Е. Джобс) Значение выражения (2**345 + 8**65 - 4**130)*(8**123 - 2**89 + 4**45) записали в восьмеричной системе
счисления. Найдите сумму всех разрядов восьмеричной записи этого числа и запишите её в ответе в
десятичной системе счисления.
"""
# # TODO: Ответ — 403
# print(sum(map(int, oct((2**345 + 8**65 - 4**130)*(8**123 - 2**89 + 4**45))[2:])))


"""
6 Значение арифметического выражения: 9**7 + 3**21 - 19 записали в системе счисления с основанием 3.
Сколько цифр «2» содержится в этой записи?"""
# # TODO: Ответ — 13
# print(to_base(9**7 + 3**21 - 19, 3).count('2'))


"""
7 Введём выражение M & K, обозначающее поразрядную конъюнкцию M и K (логическое «И» между
соответствующими битами двоичной записи). Определите наименьшее натуральное число A, такое что
выражение
(X & 49 ≠ 0) → ((X & 33 = 0) → (X & A ≠ 0))
тождественно истинно (то есть принимает значение 1 при любом натуральном значении переменной X)?
"""
# # TODO: Ответ — 16
# for A in range(1, 1000):
#     flag = True
#     for X in range(1, 1000):
#         f = (X & 49 == 0) or ((X & 33 != 0) or (X & A != 0))
#         if not f:
#             flag = False
#             break
#     if flag:
#         print(A)
#         break


"""
8 Обозначим через ДЕЛ(n, m) утверждение «натуральное число n делится без остатка на натуральное число m».
Для какого наименьшего натурального числа А формула
(ДЕЛ(x, А) ∧ ¬ДЕЛ(x, 15)) → (ДЕЛ(x, 18) ∨ ДЕЛ(x, 15))
тождественно истинна (то есть принимает значение 1 при любом натуральном значении переменной х)?
"""
# # TODO: Ответ — 15
# for A in range(1, 1000):
#     flag = True
#     for x in range(1, 1000):
#         f = x % A != 0 or x % 15 == 0 or x % 18 == 0 or x % 15 == 0
#         if not f:
#             flag = False
#             break
#     if flag:
#         print(A)
#         break


"""
9 (Е. Джобс) Алгоритм вычисления значения функции F(n), где n – целое неотрицательное число, задан
следующими соотношениями:
F(n) = 1, если n < 3
F(n) = F(n – 1) – F(n – 2), если n > 2 и сумма цифр числа n чётная,
F(n) = F(n – 1) + F(n // 2), если n > 2 и сумма цифр числа n нечётная.
Здесь // означает деление нацело. Определите значение F(100).
"""
# # TODO: Ответ — 23
# @lru_cache(None)
# def F(n):
#     if n < 3:
#         return 1
#     return F(n - 1) - F(n - 2) if not sum(map(int, str(n))) & 1 else F(n - 1) + F(n // 2)
#
#
# print(F(100))


"""
10 Алгоритм вычисления значения функции F(n), где n – натуральное число, задан следующими
соотношениями:
F(n) = 1 при n = 1
F(n) = 2·F(n–1) + n + 3, если n > 1
Чему равно значение функции F(19)?
"""
# # TODO: Ответ — 1834984
# def F(n):
#     return 1 if n == 1 else 2 * F(n - 1) + n + 3
#
#
# print(F(19))


"""
11 (А. Кабанов) В файле 17-4.txt содержится последовательность целых чисел. Элементы последовательности
могут принимать целые значения от 0 до 10 000 включительно. Рассматривается множество элементов
последовательности, которые оканчиваются либо на 2, либо на 7 и делятся на 3, 11. Найдите количество таких
чисел и минимальное из них
"""
# # TODO: Ответ — 13 1287
# with open('data/17-4.txt') as f:
#     data = list(map(int, f.readlines()))
# res = [i for i in data if (i % 10 == 2 or i % 10 == 7) and not i % 3 and not i % 11]
# print(len(res), min(res))


"""
12 В файле 17-1.txt содержится последовательность целых чисел. Элементы последовательности могут
принимать целые значения от –10 000 до 10 000 включительно. Определите количество пар, в которых хотя бы
один из двух элементов больше, чем среднее арифметическое всех чисел в файле в файле. В ответе запишите
два числа:сначала количество найденных пар, а затем – максимальную сумму элементов таких пар. В данной
задаче под парой подразумевается два идущих подряд элемента последовательности.
"""
# # TODO: Ответ — 7515 19789
# with open('data/17-1.txt') as f:
#     data = list(map(int, f.readlines()))
# avg = sum(data) / len(data)
# c = 0
# mx = -20000
# for i in range(len(data) - 1):
#     elems = data[i:i+2]
#     if any(elem > avg for elem in elems):
#         c += 1
#         mx = max(mx, sum(elems))
# print(c, mx)


"""
13 (Е. Джобс) Квадрат разлинован на N×N клеток (1 < N < 30). Исполнитель Робот может переме-щаться по
клеткам, выполняя за одно перемещение одну из двух команд: вправо или вниз. По команде вправо Робот
перемещается в соседнюю правую клетку; по команде вниз – в соседнюю нижнюю. Квадрат ограничен
внешними стенами. Между соседними клетками квадрата также могут быть внутренние стены. Сквозь стену
Робот пройти не может. Перед каждым запуском Робота в каждой клетке квадрата лежит монета достоинством
от 1 до 100. Посетив клетку, Робот забирает монету с собой; это также относится к начальной и конечной
клетке маршрута Робота. Также в лабиринте отмечена фоном одна клетка, через которую робот должен
обязательно пройти.
Исходные данные для Робота записаны в файле 18-139.xls в виде прямоугольной таблицы, каждая ячейка
которой соответствует клетке квадрата. Определите максимальную и минимальную денежную сумму, которую
может собрать Робот, пройдя из левой верхней клетки в правую нижнюю. В ответе укажите два числа – сначала
максимальную сумму, затем минимальную.
"""
# # TODO: Ответ — 2174 1415


"""
14 (ЕГЭ-2022) Квадрат разлинован на N×N клеток (1 < N < 30). Исполнитель Робот может переме-щаться по
клеткам, выполняя за одно перемещение одну из двух команд: вправо или вниз. По команде вправо Робот
перемещается в соседнюю правую клетку; по команде вниз – в соседнюю нижнюю. Квадрат ограничен
внешними стенами. Между соседними клетками квадрата также могут быть внутренние стены. Сквозь стену
Робот пройти не может. Перед каждым запуском Робота в каждой клетке квадрата лежит монета достоинством
от 1 до 100. Посетив клетку, Робот забирает монету с собой; это также относится к начальной и конечной
клетке маршрута Робота.
Исходные данные для Робота записаны в файле 18-138.xls в виде прямоугольной таблицы, каждая ячейка
которой соответствует клетке квадрата. Определите максимальную и минимальную денежную сумму, которую
может собрать Робот, пройдя из левой верхней клетки в правую нижнюю. В ответе укажите два числа – сначала
максимальную сумму, затем минимальную.
"""
# # TODO: Ответ — 2628 1659


"""
15, 16, 17 Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежат две кучи камней. Игроки
ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в одну из куч один камень или
увеличить количество камней в куче в два раза. Чтобы делать ходы, у каждого игрока есть неограниченное
количество камней. Игра завершается в тот момент, когда суммарное количество камней в кучах становится не
менее 61. Победителем считается игрок, сделавший последний ход, т. е. первым получивший позицию, в
которой в кучах будет 61 или больше камней.
В начальный момент в первой куче было 6 камней, во второй куче – S камней, 1 ≤ S ≤ 54. Будем говорить, что
игрок имеет выигрышную стратегию, если он может выиграть при любых ходах противника.
Ответьте на следующие вопросы:
Вопрос 1. Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети. Назовите
минимальное значение S, при котором это возможно.
Вопрос 2. Найдите два таких значения S, при которых у Пети есть выигрышная стратегия, причём Петя не
может выиграть первым ходом, но может выиграть своим вторым ходом независимо от того, как будет ходить
Ваня. Найденные значения запишите в ответе в порядке возрастания.
Вопрос 3. Укажите минимальное значение S, при котором у Вани есть выигрышная стратегия, позволяющая
ему выиграть первым или вторым ходом при любой игре Пети, и при этом у Вани нет стратегии, которая
позволит ему гарантированно выиграть первым ходом.
"""
# # TODO: Ответ —
# #  1) 14
# #  2) 24 26
# #  3) 23
# @lru_cache(None)
# def game1(a, b):
#     if a + b >= 61:
#         return 0
#     tmp = [game1(a + 1, b), game1(a, b + 1),
#            game1(a * 2, b), game1(a, b * 2)]
#     ng = [i for i in tmp if i <= 0]
#     if ng:
#         return -max(ng) + 1
#     return -max(tmp)
#
#
# print(*[s for s in range(1, 55) if game1(6, s) == 2])
# print(min(s for s in range(1, 55) if game1(6, s) == -2))


"""
18, 19, 20 Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит две кучи камней. Игроки
ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в любую кучу один камень или
увеличить количество камней в любой куче в три раза. Игра завершается в тот момент, когда общее
количество камней в двух кучах становится не менее 90. Победителем считается игрок, сделавший последний
ход. В начальный момент в первой куче было 9 камней, а во второй – S камней, 1 ≤ S ≤ 80.
Ответьте на следующие вопросы:
Вопрос 1. Известно, что Ваня выиграл своим первым ходом после первого хода Пети. Назовите минимальное
значение S, при котором это возможно.
Вопрос 2. Определите, сколько существует таких значений S, при которых у Пети есть выигрышная
стратегия, причём одновременно выполняются два условия:
− Петя не может выиграть за один ход;
− Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
Вопрос 3. Укажите максимальное значение S, при котором у Вани есть выигрышная стратегия, позволяющая
ему выиграть при любой игре Пети.
"""
# # TODO: Ответ —
# #  1) 9
# #  2) 1
# #  3) 26
@lru_cache(None)
def game2(a, b):
    if a + b >= 90:
        return 0
    tmp = [game2(a + 1, b), game2(a, b + 1),
           game2(a * 3, b), game2(a, b * 3)]
    ng = [i for i in tmp if i <= 0]
    if ng:
        return -max(ng) + 1
    return -max(tmp)


print(len([s for s in range(1, 81) if game2(9, s) == 2]))
print(max(s for s in range(1, 81) if game2(9, s) == -2))