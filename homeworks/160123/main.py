"""
2. (Е. Джобс) Логическая функция F задаётся выражением (a → d) ∧ ¬(b → c).
На рисунке приведён частично заполненный фрагмент
таблицы истинности функции F, содержащий неповторяющиеся строки. Определите, какому столбцу
таблицы истинности функции F соответствует каждая из переменных a, b, c, d.
"""
# # TODO: Ответ – dabc
# print('d a b c f')
# for d, a, b, c in product([0, 1], repeat=4):
#     f = int((not a or d) and not (not b or c))
#     if f:
#         print(d, a, b, c, f)


"""
5. Автомат получает на вход трёхзначное число. По этому числу строится новое число по следующим
правилам.
1. Из цифр, образующих десятичную запись N, строятся наибольшее и наименьшее возможные
двузначные числа (числа не могут начинаться с нуля).
2. На экран выводится разность полученных двузначных чисел.
Пример. Дано число N = 351. Наибольшее двузначное число из заданных цифр – 53, наименьшее – 13.
На экран выводится разность 53 – 13 = 40.
Чему равно количество трёхзначных чисел N, в результате обработки которых на экране автомата
появится число 35?
"""
# # TODO: Ответ – 882
# c = 0
# for n in range(100, 1000):
#     nmb = list(set(int(''.join(i)) for i in permutations(str(n), r=2) if 10 <= int(''.join(i)) <= 100))
#     if max(nmb) - min(nmb):
#         c += 1
# print(c)


"""
6. (А. Минак) Исполнитель Чертёжник перемещается на координатной плоскости, оставляя след в
виде линии. Чертёжник может выполнять команду Сместиться на (a,b) (где a, b — целые числа),
перемещающую Чертёжника из точки с координатами (x, y) в точку с координатами (x+a, y+b). Если
числа a, b положительные, то значение соответствующей координаты увеличивается, если
отрицательные — уменьшается. Например, если Чертёжник находится в точке с координатами (4, 2),
то команда Сместиться на (2,-3) переместит Чертёжника в точку (6,-1). Запись
Повтори k раз
 Команда1 Команда2 Команда3
конец
означает, что последовательность Команда1 Команда2 Команда3 повторится k раз.
Чертёжнику был дан для исполнения следующий алгоритм:
Повтори 10 раз
 Сместиться на (200, 100)
 Сместиться на (-50, -150)
 Сместиться на (-150, 50)
конец
Определите, сколько точек с целочисленными координатами принадлежат траектории движения
Чертёжника.
"""
# # TODO: Ответ – 200 (50 * 4 = 200)
# from turtle import *
#
# screensize(30, 30)
# speed(1000000)
# left(90)
# m = 30
# color('black')
# come = [(4 * m, 2 * m),  # 200/5 ; 100/5
#         (-1 * m, -3 * m),  # -50/5 ; -150/5
#         (-3 * m, 1 * m)]  # -150/5 ; 50/5
# x, y = 0, 0
# for j in come:
#     x, y = x + j[0], y + j[1]
#     goto(x, y)
# penup()
#
# for x in range(-10 * m, 10 * m, m):
#     for y in range(-10 * m, 10 * m, m):
#         goto(x, y)
#         dot(3, 'green')
#
# mainloop()


"""
8. Петя составляет 4-буквенные слова из букв Н, О, Д, А. Каждую букву нужно использовать ровно 1
раз, при этом нельзя ставить подряд две гласные или две согласные. Сколько различных кодов может
составить Петя?
"""
# # TODO: Ответ – 24
# c = 0
# for s in permutations('НОДА'):
#     s = ''.join(s)
#     if 'ОА' not in s or 'АО' not in s or 'НД' not in s or 'ДН' not in s:
#         c += 1
# print(c)


"""
12. Исполнитель Редактор получает на вход строку цифр и преобразовывает её. Редактор может
выполнять две команды, в обеих командах v и w обозначают цепочки цифр.
1. заменить (v, w)
2. нашлось (v)
Первая команда заменяет в строке первое слева вхождение цепочки v на цепочку w. Если цепочки v в
строке нет, эта команда не изменяет строку. Вторая команда проверяет, встречается ли цепочка v в
строке исполнителя Редактор. Если она встречается, то команда возвращает логическое значение
«истина», в противном случае возвращает значение «ложь». Дана программа для исполнителя
Редактор:
НАЧАЛО
 ПОКА нашлось (5555)
 заменить (5555, 33)
 заменить (333, 5)
 КОНЕЦ ПОКА
КОНЕЦ
Какая строка получится в результате применения приведённой ниже программы к строке, состоящей
из 150 цифр 5?
"""
# # TODO: Ответ – 5355
# s = '5' * 150
# while '5555' in s:
#     s = s.replace('5555', '33', 1)
#     s = s.replace('333', '5', 1)
# print(s)


"""
14. В какой системе счисления выполняется равенство 21X · 13X = 313X? В ответе укажите число –
основание системы счисления.
"""
# # TODO: Ответ – 6
# for x in range(4, 37):
#     if int('21', x) * int('13', x) == int('313', x):
#         print(x)


"""
15. Укажите наименьшее целое значение А, при котором выражение
(x + 3y ≠ 27) ∨ ((A > x) ∧ (A > y))
истинно для любых целых неотрицательных значений x и y
"""
# # TODO: Ответ – 28
# for A in range(100):
#     flag = True
#     for x in range(100):
#         for y in range(100):
#             if not ((x + 3*y != 27) or ((A > x) and (A > y))):
#                 flag = False
#                 break
#         if not flag:
#             break
#     if flag:
#         print(A)
#         break


"""
16. Алгоритм вычисления значений функций F(n) и G(n), где n – натуральное число, задан
следующими соотношениями:
F(1) = 1; G(1) = 1;
F(n) = F(n–1) – n·G(n–1), при n >=2
G(n) = F(n–1) + 2·G(n–1), при n >=2
Чему равно значение величины G(18)?
"""
#
#
# def F(n):
#     if n == 1: return 1
#     return F(n - 1) - n * G(n - 1)
#
#
# def G(n):
#     if n == 1: return 1
#     return F(n - 1) + 2 * G(n - 1)
#
#
# # TODO: Ответ – 87810480
# print(G(18))


"""
17. В файле 17-243.txt содержится последовательность целых чисел. Элементы последовательности
могут принимать целые значения от 0 до 10 000 включительно. Определите количество пар чисел, в
которых хотя бы один из двух элементов больше, чем наибольшее из всех чисел в файле, делящихся
на 133, и в восьмеричной записи хотя бы одного элемента из двух содержится цифра 3. В ответе
запишите два числа: сначала количество найденных пар, а затем – минимальную сумму элементов
таких пар. В данной задаче под парой подразумевается два идущих подряд элемента
последовательности.
"""
# # TODO: Ответ – 34 11169
# with open('data/17-243.txt') as f:
#     data = list(map(int, f.readlines()))
# mx133 = max([i for i in data if not (i % 133)])
# c = 0
# mn = 30000
# for i in range(len(data) - 1):
#     if any((data[i] > mx133, data[i+1] > mx133)) and any(('3' in oct(data[i])[2:], '3' in oct(data[i+1])[2:])):
#         c += 1
#         mn = min(mn, data[i] + data[i+1])
# print(c, mn)


"""
19. Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежат две кучи камней.
Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в одну из куч
три камня или увеличить количество камней в куче в два раза. Чтобы делать ходы, у каждого
игрока есть неограниченное количество камней. Игра завершается в тот момент, когда суммарное
количество камней в кучах становится не менее 75. Победителем считается игрок, сделавший
последний ход, т. е. первым получивший позицию, в которой в кучах будет 75 или больше камней.
В начальный момент в первой куче было 9 камней, во второй куче – S камней, 1 ≤ S ≤ 65. Будем
говорить, что игрок имеет выигрышную стратегию, если он может выиграть при любых ходах
противника.
Ответьте на следующие вопросы:
Вопрос 1. Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети.
Назовите минимальное значение S, при котором это возможно.
Вопрос 2. Укажите минимальное значение S, при котором у Пети есть выигрышная стратегия,
причём Петя не может выиграть первым ходом, но может выиграть своим вторым ходом независимо
от того, как будет ходить Ваня.
Вопрос 3. Найдите два значения S, при которых у Вани есть выигрышная стратегия, позволяющая
ему выиграть первым или вторым ходом при любой игре Пети, и при этом у Вани нет стратегии,
которая позволит ему гарантированно выиграть первым ходом. Найденные значения запишите в
ответе в порядке возрастания.
"""
#
#
# # TODO: Ответ – Вопрос 1: 19 (19*2*2=76); Вопрос 2: 16; Вопрос 3: 24 25
# @lru_cache(None)
# def game(x, y):
#     if x + y >= 75:
#         return 0
#     tmp = [game(x + 3, y), game(x, y + 3),
#            game(x * 2, y), game(x, y * 2)]
#     ng = [i for i in tmp if i <= 0]
#     if len(ng) != 0:
#         return -max(ng) + 1
#     return -max(tmp)
#
#
# print(min([s for s in range(1, 65) if game(9, s) == 2]))
# print([s for s in range(1, 65) if game(9, s) == -2])


"""
20. (В. Шубинкин) В файле 22-2.xls содержится информация о совокупности N вычислительных
процессов, которые могут выполняться параллельно или последовательно. Будем говорить, что
процесс B зависит от процесса A, если для выполнения процесса B необходимы результаты
выполнения процесса A. В этом случае процессы могут выполняться только последовательно.
Информация о процессах представлена в файле в виде таблицы. В первом столбце таблицы указан
идентификатор процесса (ID), во втором столбце таблицы – время его выполнения в миллисекундах, в
третьем столбце перечислены с разделителем «;» ID процессов, от которых зависит данный процесс.
Если процесс является независимым, то в таблице указано значение 0.
Определите минимальное время, через которое завершится выполнение всей совокупности
процессов, при условии, что все независимые друг от друга процессы могут выполняться
параллельно.
Типовой пример организации данных в файле:
В данном случае независимые процессы 1 и 2
могут выполняться параллельно, при этом процесс 1 завершится через 4 мс, а процесс 2 – через 3 мс с
момента старта. Процесс 3 может начаться только после завершения обоих процессов 1 и 2, то есть,
через 4 мс после старта. Он длится 1 мс и закончится через 4 + 1 = 5 мс после старта. Выполнение
процесса 4 может начаться только после завершения процесса 3, то есть, через 5 мс. Он длится 7 мс,
так что минимальное время завершения всех процессов равно 5 + 7 = 12 мс.
"""
#
#
# # TODO: Ответ – 20
# def func(data, i):
#     if '0' in data[i]['r']:
#         return data[i]['t']
#     mx = 0
#     for search in data[i]['r']:
#         f = func(data, search)
#         mx = max(mx, f)
#     data[i]['r'] = ['0']
#     data[i]['t'] += mx
#     return data[i]['t']
#
#
# with open('data/22-2.csv') as f:
#     rdr = [i for i in reader(f, delimiter=';', quotechar='"')]
#     data = {}
#     for i, t, r, e in rdr[1:]:
#         data[i] = {'t': int(t), 'r': [x.strip() for x in r.split(';')]}
# mx = 0
# for i in data:
#     f = func(data, i)
#     mx = max(mx, f)
# print(mx)


"""
21. Исполнитель Калькулятор преобразует число на экране. У исполнителя есть три команды,
которым присвоены номера:
1. Прибавить 1
2. Прибавить 2
3. Прибавить 3
Программа для исполнителя Калькулятор – это последовательность команд. Сколько существует
программ, для которых при исходном числе 3 результатом является число 15, и при этом траектория
вычислений не содержит число 8?
"""
# # TODO: Ответ – 355
# l = [0] * 100
# l[3] = 1
# for i in range(3, 16):
#     l[10] = 0
#     l[i + 1] += l[i]
#     l[i + 2] += l[i]
#     l[i + 3] += l[i]
# print(l[15])


"""
22. Текстовый файл 24-191.txt содержит строку из заглавных латинских букв, всего не более чем из
10^6 символов. Определите количество подстрок длиной не более 12 символов, которые начинаются и
заканчиваются буквой A и не содержат других букв A (кроме первой и последней) и букв B.
"""
# # TODO: Ответ – 1118
# with open('data/24-191.txt') as f:
#     s = f.readline()
# print(len([i for i in s.split('A')[1:-1] if len(i) <= 10 and 'B' not in i]))


"""
23. Пусть S(N) – сумма трёх наибольших нетривиальных делителей числа N (не считая единицы и
самого числа). Если у числа N меньше трёх таких делителей, то S(N) считается равным 0. Найдите 5
наименьших натуральных чисел, превышающих 10 000 000, для которых в десятичной записи S(N)
все цифры расположены в порядке неубывания. В ответе запишите найденные значения S(N) в
порядке возрастания соответствующих им чисел N.
"""
#
#
# def dels(x: int) -> list:
#     a = []
#     i = 2
#     while i ** 2 <= x:
#         if i ** 2 == x:
#             a.append(i)
#         elif x % i == 0:
#             a += [i, x // i]
#         i += 1
#     a.sort()
#     return a
#
#
# def f(x):
#     if x:
#         return sorted(map(int, str(x))) == list(map(int, str(x)))
#     return False
#
#
# # TODO: Ответ – 2569999 467999 2444457 4457789 4446677
# a = []
# x = 10000001
# while len(a) < 5:
#     divs = dels(x)
#     if len(divs) >= 3:
#         s = sum(divs[-3:])
#         if f(s):
#             a.append(s)
#     x += 1
# print(*a)


"""
24. (М. Шагитов) В одном из конференц-залов города Н проводится научная конференция. Известно,
какие места в зале уже забронированы для участников конференции из других городов и для
участников конференции из города Н. Найдите ряд с наибольшим номером, в котором есть ровно сто
свободных мест подряд между участниками из других городов, а также хотя бы пятьсот мест, занятых
участниками из города Н. Гарантируется, что есть хотя бы один ряд, удовлетворяющий этому
условию.
Входные данные представлены в файле 26-85.txt следующим образом. В первой строке входного
файла записано натуральное число N – общее количество занятых мест (1 ≤ N ≤ 600 000). В каждой из
следующих N строках находятся по три натуральных числа, не превышающих 25 000. Первые два
числа – это номер ряда и место в ряду, занятое участником конференции. Если третье число равно 0,
то место занято участником из города Н, а если оно равно 1, то участником из другого города.
Запишите в ответе два числа: максимальный номер подходящего ряда и количество мест, занятых в
этом ряду участниками из других городов.
Пример входного файла::
15
1 1 0
1 3 1
1 5 0
1 7 1
1 8 0
2 3 1
2 8 1
2 9 0
2 10 0
3 1 0
3 2 1
3 6 1
3 7 0
3 8 0
3 9 0
В примере требуется найти ряд, в котором есть ровно три свободных места между участниками из
других городов, а также хотя бы четыре занятых места, занятые участниками из города Н. В 3-м ряду
есть 3 свободных места подряд между участниками из других городов (места 3, 4 и 5) и 4 места
заняты участниками из города Н. В этом ряду 2 места заняты участниками из других городов (места 2
и 6). Ответ: 3 2.
"""
# # TODO: Ответ – 17384 5090
# with open('data/26-85.txt') as f:
#     n = int(f.readline())
#     stream = map(lambda x: tuple(map(int, x.split())), f.readlines())
# cityn = {}
# cityo = {}
# for row, col, city in stream:
#     if not city:
#         cityn[row] = cityn.get(row, []) + [col]
#     else:
#         cityo[row] = cityo.get(row, []) + [col]
# employ = [i[0] for i in cityn.items() if len(i[1]) >= 500]
# for i in cityo.items():
#     if i[0] in employ:
#         t0 = sorted(cityn[i[0]])
#         t1 = sorted(cityo[i[0]])
#         if len([1 for i1, i2 in zip(t1, t1[1:]) if i2 - i1 == 100 + 1]) >= 1:
#             if all(x not in t0 for x in t1):
#                 print(i[0], len(t1))


"""
25. (99 баллов) На вход программе поступают пары чисел. В каждой паре первое число
положительное, второе - отрицательное. Из каждой пары можно выбрать одно число или не выбирать
никакого (пропустить ход). При этом нельзя выбирать первое число в паре больше, чем K раз подряд
(пропуски хода не учитываются). Найдите максимальную сумму, которую можно получить после
обработки всех пар.
Входные данные. Даны два входных файла (файл A и файл B), содержит в первой строке число N (1
≤ N ≤ 1 000 000) – количество пар, и число K (1 ≤ K ≤ 100 000) – наибольшее количество ходов с
выбором положительных чисел подряд. Каждая из следующих N строк содержит два целых числа, не
превышающих по модулю 1000 (первое число в паре положительное, второе – отрицательное).
Пример входного файла:
6 3
350 -450
250 -150
350 -350
100 -350
450 -150
150 -150
При этих данных можно выбрать в первых трёх строках первое число, это дает сумму 350 + 250 + 350
= 950. Из четвёртой строки берём второе число, получаем 950 - 350 = 600. В последних двух строках
берем первое число, получая 600 + 450 + 150 = 1200. Ответ: 1200.
В ответе укажите два числа: сначала искомое значение для файла А, затем для файла B.
"""


def calc(n=6, k=3, data=None):
    if data is None:
        data = [(350, -450), (250, -150), (350, -350), (100, -350), (450, -150), (150, -150)]
    res = [[0] * (k + 1) for i in range(2)]
    for i, elem in enumerate(data):
        for j in range(k + 1):
            res[1][j] = max(res[0][j], elem[0] + res[0][j - 1] if j else elem[1] + max(res[0]))
        res[0], res[1] = res[1], res[0]
    print(max(res[0]))


# calc()

# TODO: Ответ – 5764
with open('data/27-110a.txt') as f:
    n, k = map(int, f.readline().split())
    data = list(map(lambda x: tuple(map(int, x.split())), f.readlines()))
calc(n=n, k=k, data=data)

# TODO: Ответ – 2511986
with open('data/27-110b.txt') as f:
    n, k = map(int, f.readline().split())
    data = list(map(lambda x: tuple(map(int, x.split())), f.readlines()))
calc(n=n, k=k, data=data)
