from itertools import product
from functools import lru_cache
from csv import reader

"""
2. Логическая функция F задаётся выражением (¬x ∨ z) ∧ (¬x ∨ ¬y ∨ ¬z).
На рисунке приведён фрагмент таблицы истинности функции F,
содержащий все наборы аргументов, при которых функция F ложна. Определите, какому столбцу
таблицы истинности функции F соответствует каждая из переменных x, y, z.
"""
### TODO: Ответ – yxzf
##print('x y z f')
##for x, y, z in product([0, 1], repeat=3):
##    f = int((not x or z) and (not x or not y or not z))
##    if not f:
##        print(y, x, z, f)


"""
5. (В. Шубинкин) Автомат производит первичную проверку правильности номера банковской карты.
Он получает на вход число N из 16 цифр и обрабатывает его по следующему правилу (вариант
алгоритма Лу́на):
1) Цифры числа нумеруются справа налево, начиная с нуля.
2) Цифры, стоящие на нечётных позициях, увеличиваются в два раза. Если при этом получается
двузначное число, его цифры складываются.
3) Складываются все цифры на чётных позициях и преобразованные цифры на нечётных позициях.
4) Если полученная сумма кратна 10, считается, что номер корректный.
Например, для числа 4096 8308 0309 8323 сумма цифр на чётных позициях (с конца)
3+3+9+3+8+3+6+0=35, сумма преобразованных цифр на нечётных позициях 4+7+0+0+0+7+9+8=35.
Общая сумма 70 кратна 10, значит номер корректен.
Определите наименьшее число N, большее 1234 5678 9101 1121, которое может быть корректным
номером согласно указанному алгоритму. Укажите в ответе последние 8 цифр числа
"""
### TODO: Ответ – 91011128
##for i in range(1234567891011121, 10000000000000000):
####    n = (4, 0, 9, 6, 8, 3, 0, 8, 0, 3, 0, 9, 8, 3, 2, 3)
##    n = tuple(map(int, str(i)))
##    if n[0] == 0:
##        continue
##    nch = list(map(lambda x: sum(map(int, str(x * 2))), n))
##    if sum([nch[i] for i in range(len(nch)) if not (i % 2)] + [n[i] for i in range(len(n)) if i % 2]) % 10 == 0:
##        print(n)
##        break



"""
6. (В. Шубинкин) Исполнитель Чертёжник перемещается на координатной плоскости, оставляя след в
виде линии. Чертёжник может выполнять команду сместиться на (a, b), где a, b – целые числа. Эта
команда перемещает Чертёжника из точки с координатами (x, y) в точку с координатами (x + a; y + b).
Например, если Чертёжник находится в точке с координатами (4, 2), то команда сместиться на (2, −3)
переместит Чертёжника в точку (6, −1). Цикл
ПОВТОРИ число РАЗ
последовательность команд
КОНЕЦ ПОВТОРИ
означает, что последовательность команд будет выполнена указанное число раз (число должно быть
натуральным). Чертёжнику был дан для исполнения следующий алгоритм:
ПОВТОРИ 7 РАЗ
сместиться на (6, -9)
сместиться на (-6, 2)
сместиться на (12, 3)
КОНЕЦ ПОВТОРИ
Определите, сколько точек с целочисленными координатами окажутся внутри замкнутых треугольных
областей (считая границы), образованных линией, оставленной Чертёжником, если исполнитель
стартует в точке с целочисленными координатами
"""
### TODO: Ответ – 42 (6*7=42)
##from turtle import *
##
##screensize(30, 30)
##speed(1000000)
##left(90)
##m = 15
##color('black')
##come = [(6 * m, -9 * m),
##        (-6 * m, 2 * m),
##        (12 * m, 3 * m)]
##x, y = 0, 0
##for j in come:
##    x, y = x + j[0], y + j[1]
##    goto(x, y)
##penup()
##
##for x in range(-10 * m, 10 * m, m):
##    for y in range(-10 * m, 10 * m, m):
##        goto(x, y)
##        dot(3, 'green')
##
##mainloop()


"""
7. Рисунок размером 512 на 256 пикселей занимает в памяти 64 Кбайт (без учёта сжатия). Найдите
максимально возможное количество цветов в палитре изображения.
"""
### TODO: Ответ – 16
##print(2**((64*2**13)//(512*256)))


"""
8. Все 5-буквенные слова, составленные из букв П, О, Р, Т, записаны в алфавитном порядке и
пронумерованы. Вот начало списка:
1. ООООО
2. ООООП
3. ООООР
4. ООООТ
5. ОООПО
...
Какое количество слов находятся между словами ТОПОР и РОПОТ (включая эти слова)?
"""
### TODO: Ответ – 186
##c = 0
##f = False
##for s in product('ПОРТ', repeat=5):
##    s = ''.join(s)
##    if s == 'ТОПОР':
##        f = True
##    if f:
##        c += 1
##    if s == 'РОПОТ':
##        f = False
##print(c)


"""
14. (Е.А. Мирончик) Какая первая цифра в шестнадцатеричной записи числа 2379 + 2378 + 2377?
"""
### TODO: Ответ – e
##print(hex(2**379 + 2**378 + 2**377)[2])


"""
15. Обозначим через ДЕЛ(n, m) утверждение «натуральное число n делится без остатка на
натуральное число m». Для какого наименьшего натурального числа А формула
ДЕЛ(x,А) → (¬ДЕЛ(x,21) ∨ ДЕЛ(x,35))
тождественно истинна (то есть принимает значение 1 при любом натуральном значении переменной
х)?
"""
### TODO: Ответ – 1
##for A in range(1, 1000):
##    flag = True
##    for x in range(1, 1000):
##        if not(x % A != 0 or (x % 21 != 0 or x % 35 == 0)):
##            flag = False
##            break
##    if flag:
##        print(A)
##        break


"""
16. Алгоритм вычисления значения функции F(n), где n – натуральное число, задан следующими
соотношениями:
F(n) = 1 при n = 1
F(n) = 2·F(n–1), если n > 1 и чётно,
F(n) = 5·n + F(n–2), если n > 1 и нечётно.
Чему равно значение функции F(64)?
"""
### TODO: Ответ – 10232
##def F(n):
##    if n == 1:
##        return 1
##    if not (n % 2):
##        return 2 * F(n-1)
##    return 5 * n + F(n-2)
##
##
##print(F(64))


"""
17. В файле 17-243.txt содержится последовательность целых чисел. Элементы последовательности
могут принимать целые значения от 0 до 10 000 включительно. Определите количество пар чисел, в
которых ровно один из двух элементов больше, чем сумма цифр всех чисел в файле, делящихся на 49,
а десятичная запись другого оканчивается на 7. В ответе запишите два числа: сначала количество
найденных пар, а затем – минимальную сумму элементов таких пар. В данной задаче под парой
подразумевается два идущих подряд элемента последовательности.
"""
### TODO: Ответ – 1360 4867
##with open('data/17-243.txt') as f:
##    data = list(map(int, f.readlines()))
##s49 = sum([sum(map(int, str(i))) for i in data if not(i % 49)])
##c = 0
##mn = 30000
##for i in range(len(data)-1):
##    if data[i] > s49 and data[i+1] % 10 == 7 or data[i+1] > s49 and data[i] % 10 == 7:
##        c += 1
##        mn = min(mn, data[i] + data[i+1])
##print(c, mn)


"""
19. (PRO100 ЕГЭ) Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит куча
камней. Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может увеличить
количество камней в куче в два раза или добавить в кучу два камня. Так же за всю игру можно только
один раз сделать суперход — ход, после которого количество камней в куче не изменится, а очередь
хода перейдёт к сопернику. То есть суперход может сделать один раз либо Ваня, либо Петя. Для того
чтобы делать ходы, у каждого игрока есть неограниченное количество камней. Выигрывает тот игрок,
после хода которого количество камней в куче становится не менее 20.
В начальный момент в куче было S камней; 1 ≤ S ≤ 19. Будем говорить, что игрок имеет выигрышную
стратегию, если он может выиграть при любых ходах противника.
Ответьте на следующие вопросы:
Вопрос 1. Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети.
Назовите минимальное значение S, при котором это возможно.
Вопрос 2. Найдите два значения S, при которых у Пети есть выигрышная стратегия, причём Петя не
может выиграть первым ходом, но может выиграть своим вторым ходом независимо от того, как будет
ходить Ваня. Найденные значения запишите в ответе в порядке возрастания.
Вопрос 3. Найдите наибольшее и наименьшее значения S, при которых у Вани есть выигрышная
стратегия. Найденные значения запишите в ответе в порядке возрастания.
"""
### TODO: Ответ – 1) 5; 2) 8 9; 3) 1 7
##@lru_cache(None)
##def game(x, sup=False): 
##    if x >= 20:
##        return 0
##    if sup:
##        tmp = [game(x), game(x*2, sup=True), game(x+2, sup=True)]
##    else:
##        tmp = [game(x*2), game(x+2)]
##    negative = [i for i in tmp if i <= 0] 
##    if len(negative) != 0: 
##        return -max(negative)+1 
##    else:
##        return -max(tmp)
##
##print(*[i for i in range(1, 20) if game(i, sup=True) == 2])
##three = [i for i in range(1, 20) if game(i, sup=True) < 0]
##print(three[0], three[-1])


"""
20. (PRO100 ЕГЭ) В файле 22-30.xls содержится информация о совокупности N вычислительных
процессов, которые могут выполняться параллельно или последовательно. Будем говорить, что
процесс B зависит от процесса A, если для выполнения процесса B требуется, чтобы был выполнен
хотя бы 50% от количества процессов А. Информация о процессах представлена в файле в виде
таблицы. В первом столбце таблицы указан идентификатор процесса (ID), во втором столбце таблицы
– время его выполнения в миллисекундах, в третьем столбце перечислены с разделителем «;» ID
процессов, от которых зависит данный процесс. Если процесс является независимым, то в таблице
указано значение 0.
Определите минимальное время, через которое завершится выполнение всей совокупности
процессов, при условии, что все независимые друг от друга процессы могут выполняться
параллельно.
Типовой пример организации данных в файле:
В данном случае независимые
процессы 1 и 2 могут выполняться параллельно, при этом процесс 1 завершится через 4 мс, а процесс
2 – через 3 мс с момента старта. Процесс 3 может начаться только после завершения хотя бы 50% из
двух процессов, то есть любого процесса 1 или 2, то есть, через 3 мс после старта. Он длится 1 мс и
закончится через 3 + 1 = 4 мс после старта.
Выполнение процесса 4 может начаться только после завершения хотя бы 50% из трёх процессов, то
есть любых двух из процессов (1, 2, 3), то есть, через 4 мс. Он длится 7 мс, так что минимальное
время завершения всех процессов равно 4 + 7 = 11 мс.
"""
### TODO: Ответ – 16
##def calc(data,i):
##    if '0' in data[i]['r']:
##        return data[i]['t']
##    a = []
##    for search in data[i]['r']:
##        f = calc(data,search)
##        a.append(f)
##    a.sort()
##    if not(len(a)%2):
##        mx = max(a[:len(a)//2])
##    else:
##        mx = max(a[:len(a)//2 + 1])
##    data[i]['r'] = ['0']
##    data[i]['t'] += mx
##    return data[i]['t']
##
##with open('data/22-30.csv') as f:
##    rdr = [i for i in reader(f, delimiter=';', quotechar='"')]
##    data = {}
##    for i, t, r, in rdr[1:]:
##        data[i] = {'t': int(t), 'r': [x.strip() for x in r.split(';')]}
##mx = 0
##for i in data:
##    f = calc(data,i)
##    mx = max(f,mx)
##print(mx)


"""
21. Исполнитель Калькулятор преобразует число на экране. У исполнителя есть три команды,
которым присвоены номера:
1. Прибавить 1
2. Умножить на 2
3. Умножить на 4
Программа для исполнителя Калькулятор – это последовательность команд. Сколько существует
программ, для которых при исходном числе 1 результатом является число 17?
"""
### TODO: Ответ – 54
##l = [0] * 100 
##l[1] = 1
##for i in range(1, 20):
##    l[i+1] += l[i]
##    l[i*2] += l[i]
##    l[i*4] += l[i]
##print(l[17])


"""
22. Текстовый файл 24-181.txt содержит строку из заглавных латинских букв и точек, всего не более
106 символов. Определите максимальное количество идущих подряд символов, среди которых не
более одной точки.
"""
### TODO: Ответ – 353
##with open("data/24-181.txt") as f:
##    s = f.readline()
##swod = s.split('.')
##mx = 0
##for i in range(len(swod)-1):
##    mx = max(mx, len(swod[i]) + len(swod[i+1]) + 1)
##print(mx)


"""
23. Пусть S (N) – сумма трёх наибольших нетривиальных делителей числа N (не считая единицы и
самого числа). Если у числа N меньше трёх таких делителей, то S (N) считается равным 0. Найдите 5
наименьших натуральных чисел, превышающих 10 000 000, для которых десятичная запись S (N)
содержит не менее четырёх цифр 7. В ответе запишите найденные значения S (N) в порядке
возрастания соответствующих им чисел N.
"""
### TODO: Ответ – 2772677 8750777 7501777 3377771 7772735
##def dels(x: int) -> list:
##    a = []
##    i = 2
##    while i ** 2 <= x:
##        if i ** 2 == x:
##            a.append(i)
##        elif x % i == 0:
##            a += [i, x // i]
##        i += 1
##    a.sort()
##    return a
##
##
##def f(x):
##    if x:
##        return str(x).count('7') >= 4
##    return False
##
##
##a = []
##x = 10000001
##while len(a) < 5:
##    divs = dels(x)
##    if len(divs) >= 3:
##        s = sum(divs[-3:])
##        if f(s):
##            a.append(s)
##    x += 1
##print(*a)


"""
24. (Е. Джобс) Системный администратор раз в неделю создаёт архив пользовательских файлов.
Однако объём диска, куда он помещает архив, может быть меньше, чем суммарный объём
архивируемых файлов. Известно, какой объём занимает файл каждого пользователя. Администратор
сохраняет файлы по следующему правилу: выбирается файл максимального размера, который может
быть записан на диск, затем выбирается файл минимального размера, который может быть записан на
диск. Данный сценарий повторяется до тех пор, пока на диск нельзя будет записать ни одного из
оставшихся файлов.
Входные данные. Первая строка входного файла 26-j9.txt записаны два числа: S – размер свободного
места на диске (натуральное число, не превышающее 10000) и N – количество пользователей
(натуральное число, не превышающее 1000). В следующих N строках находятся значения объёмов
файлов каждого пользователя (все числа натуральные, не превышающие 100), каждое в отдельной
строке.
Запишите в ответе два числа: сначала наибольшее число пользователей, чьи файлы могут быть
помещены в архив, затем размер последнего сохраненного файла.
Пример входного файла:
100 5
80
30
10
57
При таких исходных данных можно сохранить файлы трех пользователей. Объёмы этих трёх файлов
80, 5 и 10. Последний выбранный файл имеет размер 10 , поэтому ответ для приведённого примера: 3
10.
"""
### TODO: Ответ – 573 229
with open('data/26-j9.txt') as f:
   s, n = map(int, f.readline().split())
   data = list(map(int, f.readlines()))
m = s
data.sort()
res = []
flag = True
while flag:
    for i in range(len(data)-1,-1,-1):
        if data and m - sum(res) - data[i] >= 0:
            res.append(data.pop(i))
            break
    if data and m - sum(res) - data[0] >= 0:
        res.append(data.pop(0))
    else:
        break
print(len(res), res[-1])
