from itertools import product
from functools import lru_cache
from copy import deepcopy

def to_base(n, b):
    a = [str(i) for i in range(10)] + [chr(l) for l in range(ord('a'), ord('z') + 1)]
    r = a[n % b]
    while n >= b:
        n //= b
        r += a[n % b]
    return r[::-1]

'''
1 (А. Игнатюк) Исполнитель Редактор получает на вход строку цифр и преобразовывает её. Редактор может
выполнять две команды, в обеих командах v и w обозначают цепочки символов.
1. заменить (v, w)
2. нашлось (v)
Первая команда заменяет в строке первое слева вхождение цепочки v на цепочку w. Если цепочки v в строке
нет, эта команда не изменяет строку. Вторая команда проверяет, встречается ли цепочка v в строке исполнителя
Редактор.
Дана программа для исполнителя Редактор:
НАЧАЛО
ПОКА нашлось (31) ИЛИ нашлось (33) ИЛИ нашлось (21)
ЕСЛИ нашлось (31)
ТО заменить (31, 123)
КОНЕЦ ЕСЛИ
ЕСЛИ нашлось(33)
ТО заменить (33, 211)
КОНЕЦ ЕСЛИ
ЕСЛИ нашлось (21)
ТО заменить (21, 1)
КОНЕЦ ЕСЛИ
КОНЕЦ ПОКА
КОНЕЦ
На вход программы поступает строка, содержащая сначала 15 цифр 3, затем 18 цифр 2, а затем n цифр 1 (n > 0).
При каком минимальном значении n в строке, полученной в результате работы программы, сумма цифр будет
более 24?
'''
### TODO: Ответ – 6
##for n in range(1, 100):
##    s = '3' * 15 + '2' * 18 + '1' * n
##    while '31' in s or '33' in s or '21' in s:
##        if '31' in s:
##            s = s.replace('31', '123', 1)
##        if '33' in s:
##            s = s.replace('33', '211', 1)
##        if '21' in s:
##            s = s.replace('21', '1', 1)
##    if sum(map(int, s)) > 24:
##        print(n)
##        break


'''
2 Исполнитель Редактор получает на вход строку цифр и преобразовывает её. Редактор может выполнять две
команды, в обеих командах v и w обозначают цепочки символов.
1. заменить (v, w)
2. нашлось (v)
Первая команда заменяет в строке первое слева вхождение цепочки v на цепочку w. Если цепочки v в строке
нет, эта команда не изменяет строку. Вторая команда проверяет, встречается ли цепочка v в строке исполнителя
Редактор.
Дана программа для исполнителя Редактор:
ПОКА нашлось (555) ИЛИ нашлось (888)
заменить (555, 8)
заменить (888, 55)
КОНЕЦ ПОКА
Известно, что начальная строка состоит более чем из 100 цифр 8 и не содержит других символов. В ходе
работы алгоритма получилась строка, не содержащая цифр 5. Укажите минимальную возможную длину
входной строки.
'''
### TODO: Ответ – 107
##for i in range(101, 1000):
##    s = '8' * i
##    while '555' in s or '888' in s:
##        s = s.replace('555', '8', 1)
##        s = s.replace('888', '55', 1)
##    if '5' not in s:
##        print(i)
##        break


'''
3 Исполнитель Чертёжник перемещается на координатной плоскости, оставляя след в виде линии. Чертёжник
может выполнять команду Сместиться на (a, b) (где a, b – целые числа), перемещающую Чертёжника из точки
с координатами (x, y) в точку с координатами (x + a, y + b). Чертёжнику был дан для исполнения следующий
алгоритм:
Сместиться на (16, -21)
Повтори N раз
Сместиться на (a, b)
Сместиться на (-1, -2)
конец
Сместиться на (-60, -12)
После выполнения этого алгоритма Чертёжник возвращается в исходную точку. Какое наибольшее число
повторений могло быть указано в конструкции «Повтори … раз»?
'''
### TODO: Ответ – 11


'''
4 (Е.А. Мирончик) Некоторое число X из десятичной системы счисления перевели в системы счисления с
основаниями 16, 8 и 4. Часть символов при записи утеряна. Позиции утерянных символов обозначены
символом *:
X = *7*16 = 5*68 = ***1*4 .
Определите число X.
'''
### TODO: Ответ – 358
##for X in range(10000):
##    for hx in product('0123456789abcdef', repeat=2):
##        if hx[0] == '0':
##            continue
##        for od in product('01234567', repeat=1):
##            for fr in product('0123', repeat=4):
##                if fr[0] == '0':
##                    continue
##                if X == \
##                   int(hx[0] + '6' + hx[1], 16) == \
##                   int('5' + od[0] + '6', 8) == \
##                   int(''.join(fr[0:3]) + '1' + fr[3], 4):
##                    print(X)
##    print('+1')


'''
5 (Е.А. Мирончик) Выражение 44·569 – 70 записано в системе счисления с основанием 5. Определите, сколько в
этой записи цифр 2
'''
### TODO: Ответ – 2
##print(to_base(4**4 * 5**69 - 70, 5).count('2'))
            

'''
6 (С.С. Поляков) Значение выражения (2∙343123 + 2401)∙(3∙343137 – 2401) записали в системе
счисления с основанием 7. Сколько цифр 6 содержится в этой записи?
'''
### TODO: Ответ – 407
##print(to_base((2 * 343**123 + 2401)*(3 * 343**137 - 2401), 7).count('6'))


'''
10 Функция F(n), где n – натуральное число, задана следующим образом:
Чему будет равно значение, вычисленное алгоритмом при выполнении вызова F(3)?
'''
### TODO: Ответ – 147
##def F(n):
##    if n < 6:
##        return n + F(n+3)*F(2*n)
##    else:
##        return 2*n
##
##print(F(3))


'''
19, 20, 21 Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежат две кучи камней. Игроки
ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в одну из куч два камня или
увеличить количество камней в куче в два раза. Чтобы делать ходы, у каждого игрока есть неограниченное
количество камней. Игра завершается в тот момент, когда суммарное количество камней в кучах становится не
менее 69. Победителем считается игрок, сделавший последний ход, т. е. первым получивший позицию, в
которой в кучах будет 69 или больше камней.В начальный момент в первой куче было 5 камней,
во второй куче – S камней, 1 ≤ S ≤ 63. Будем говорить, что
игрок имеет выигрышную стратегию, если он может выиграть при любых ходах противника.
Ответьте на следующие вопросы:
Вопрос 1. Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети. Назовите
минимальное значение S, при котором это возможно.
Вопрос 2. Укажите минимальное значение S, при котором у Пети есть выигрышная стратегия, причём Петя не
может выиграть первым ходом, но может выиграть своим вторым ходом независимо от того, как будет ходить
Ваня.
Вопрос 3. Найдите два значения S, при которых у Вани есть выигрышная стратегия, позволяющая ему
выиграть первым или вторым ходом при любой игре Пети, и при этом у Вани нет стратегии, которая позволит
ему гарантированно выиграть первым ходом. Найденные значения запишите в ответе в порядке возрастания.
'''
### TODO: Ответ –
###  19) 13
###  20) 29
###  21) 27 28
##@lru_cache(None) 
##def game(x, y):
##    if x + y >= 69:
##        return 0
##    tmp = [game(x+2,y), game(x, y+2),
##           game(x*2, y), game(x, y*2)]
##    negative = [i for i in tmp if i <= 0]
##    if negative:
##        return -max(negative)+1
##    return -max(tmp)
##
##
##print(min(i for i in range(1, 64) if game(5, i) == 2))
##print(*[i for i in range(1, 64) if game(5, i) == -2])


'''
22, 23, 24 (Е. Джобс) Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит куча камней.
Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в кучу 10 камней или
увеличить количество камней в куче в два раза. Игра завершается в тот момент, когда количество камней в куче
становится не менее 82. Игрок, сделавший ход, который привел к значению 82 или более, считается
проигравшим. В начальный момент в куче было S камней, 1 ≤ S ≤ 81.
Ответьте на следующие вопросы:
Вопрос 1. Известно, что Петя одержал победу, совершив один ход за игру. Найдите минимальное значение S,
при котором Петя гарантированно одерживает победу.
Вопрос 2. Найдите все значения S такие, при которых Ваня совершает не более одного хода и выигрывает.
При этом у Вани нет стратегии, которая позволяла бы ему гарантированно выиграть, не совершив ни одного
хода. В качестве ответа приведите минимальное и максимальное значения S.
Вопрос 3. Известно, что Петя выигрывает, сделав не более двух ходов. Укажите минимальное значение S,
если известно, что Петя не может гарантированно выиграть, сделав один ход.
'''
### TODO: Ответ –
###  22) 41
###  23) 31 40
###  24) 16
##@lru_cache(None) 
##def game(x):
##    if x >= 82:
##        return 0
##    tmp = [game(x+10), game(x*2)]
##    negative = [i for i in tmp if i <= 0]
##    if negative:
##        return -max(negative)+1
##    return -max(tmp)
##
##
##print(min(i for i in range(1, 82) if game(i) == 1))
##t2 = [i for i in range(1, 82) if game(i) == -1]
##print(min(t2), max(t2))
##print(min(i for i in range(1, 82) if game(i) == 2))


'''
25, 26, 27 (PRO100 ЕГЭ) Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит куча
камней. Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может увеличить количество
камней в куче в два раза или добавить в кучу два камня. Так же за всю игру можно только один раз сделать
суперход — ход, после которого количество камней в куче не изменится, а очередь хода перейдёт к сопернику.
То есть суперход может сделать один раз либо Ваня, либо Петя. Для того чтобы делать ходы, у каждого игрока
есть неограниченное количество камней. Выигрывает тот игрок, после хода которого количество камней в куче
становится не менее 20.
В начальный момент в куче было S камней; 1 ≤ S ≤ 19. Будем говорить, что игрок имеет выигрышную
стратегию, если он может выиграть при любых ходах противника.
Ответьте на следующие вопросы:
Вопрос 1. Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети. Назовите
минимальное значение S, при котором это возможно.
Вопрос 2. Найдите два значения S, при которых у Пети есть выигрышная стратегия, причём Петя не может
выиграть первым ходом, но может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
Найденные значения запишите в ответе в порядке возрастания.
Вопрос 3. Найдите наименьшее и наибольшее значения S, при которых у Вани есть выигрышная стратегия.
Найденные значения запишите в ответе в порядке возрастания.
'''
### TODO: Ответ –
###  25) 5
###  26) 8 9
###  27) 6 7
##@lru_cache(None) 
##def game(x, s=True):
##    if x >= 20:
##        return 0
##    tmp = [game(x*2, s=s), game(x+2, s=s)]
##    if s:
##        tmp += [game(x, s=False)]
##    negative = [i for i in tmp if i <= 0]
##    if negative:
##        return -max(negative)+1
##    return -max(tmp)
##
##
##
##print(*[i for i in range(1, 20) if game(i) == 2])
##t3 = [i for i in range(1, 20) if game(i) == -2]
##print(min(t3), max(t3))


'''
28 (Е. Джобс) Исполнитель преобразует число, записанное на экране. У исполнителя есть две команды,
которым присвоены номера:
1. Прибавь 2
2. Вычти 3
Первая команда увеличивает число на экране на 2, вторая уменьшает на 3. При выходе за пределы отрезка [–40;
40] исполнитель аварийно завершает свою работу. Программа для исполнителя – это последовательность
команд. Сколько существует таких программ, которые исходное число 1 преобразуют в число 30 и при этом
траектория вычислений не содержит одинаковых чисел?
'''
### TODO: Ответ – 361
def f(x, n, k):
    if x > n or not (-40 <= x <= 40): 
        return 0
    if x == n:
        return 1
    c = 0
    if x + 2 not in k:
        c += f(x+2, n, k + [x+2])
    if x - 3 not in k:
        c += f(x-3, n, k + [x-3])
    return c


print(f(1, 30, [1]))


'''
29 (С.С. Поляков) У исполнителя Калькулятор есть три команды, которым присвоены номера:
1. Прибавить 1
2. Прибавить 2
3. Умножить на 2
Сколько разных чисел на отрезке [34, 59] может быть получено из числа 1 с помощью программ, состоящих из
6 команд?
'''
### TODO: Ответ – 11
##s = set() 
##def f(x, n):
##    if n == 6:
##        s.add(x) 
##        return 0
##    f(x+1, n+1) 
##    f(x+2, n+1)
##    f(x*2, n+1)
##f(1, 0)
##print(len([i for i in s if 34 <= i <= 59]))


'''
30 Исполнитель Калькулятор преобразует число на экране. У исполнителя есть две команды, которым
присвоены номера:
1. Прибавить 1
2. Прибавить 2
Программа для исполнителя Калькулятор – это последовательность команд. Сколько существует программ, для
которых при исходном числе 4 результатом является число 14, предпоследней командой которых является
команда «1»?
'''
### TODO: Ответ – 55
##def f(x, n, k):
##    if x > n: 
##        return 0
##    if x == n and k[-2] == 1:
##        return 1
##    return f(x+1, n, k + [1]) + f(x+2, n, k + [2])
##
##
##print(f(4, 14, []))

