from pprint import pprint
from csv import reader


'''
1)	(В. Шубинкин) В файле 22-1.xls содержится информация о совокупности N
вычислительных процессов, которые могут выполняться параллельно или
последовательно. Будем говорить, что процесс B зависит от процесса A,
если для выполнения процесса B необходимы результаты выполнения процесса A.
В этом случае процессы могут выполняться только последовательно.
Информация о процессах представлена в файле в виде таблицы.
В первом столбце таблицы указан идентификатор процесса (ID),
во втором столбце таблицы – время его выполнения в миллисекундах,
в третьем столбце перечислены с разделителем «;» ID процессов,
от которых зависит данный процесс. Если процесс является независимым,
то в таблице указано значение 0.
Определите минимальное время, через которое завершится выполнение всей
совокупности процессов, при условии, что все независимые друг от друга
процессы могут выполняться параллельно.
Типовой пример организации данных в файле:
ID процесса B	Время выполнения процесса B (мс)	ID процесса(ов) A
1	4	0
2	3	0
3	1	1; 2
4	7	3
В данном случае независимые процессы 1 и 2 могут выполняться параллельно,
при этом процесс 1 завершится через 4 мс, а процесс 2 – через 3 мс с момента
старта. Процесс 3 может начаться только после завершения обоих процессов 1 и 2,
то есть, через 4 мс после старта. Он длится 1 мс и закончится через
4 + 1 = 5 мс после старта. Выполнение процесса 4 может начаться только после
завершения процесса 3, то есть, через 5 мс. Он длится 7 мс,
так что минимальное время завершения всех процессов равно 5 + 7 = 12 мс.
'''
##def calc(data, i):  # Рекурсивная функция поиска времени процесса
##    if '0' in data[i]['rel']:  # Если процесс независимый,
##        return data[i]['time']  # то выводим известное время
##    mx = 0  # Т.к. следующий процесс выполняется после предыдущего, работаем с максимумом
##    for search in data[i]['rel']:  # Собираем время со всех зависимых процессов
##        f = calc(data, search)  # Изучение зависимых процессов
##        mx = max(mx, f)  # Сравнение с уже известными процессами
##    data[i]['rel'] = ['0']  # Т.к. все зависымые изучены, сообщаем об отсутствии процессов
##    data[i]['time'] += mx  # и суммируем к стандартному времени всё время процессов
##    return data[i]['time']  # Возвращаем найденное время процесса
##
##with open('data/22-1.csv') as f:  # Считываем таблицу, которую ранее преобразовали в CSV
##    rdr = [i for i in reader(f, delimiter=';', quotechar='"')]  # Задаём параметры для считывания
##    data = {}  # Записываем найденные данные в словарь
##    for i, time, rel, empty in rdr[1:]:
##        data[i] = {'time': int(time), 'rel': [x.strip() for x in rel.split(';')]}
##print('Data: ')
##pprint(data)  # Выводим найденное через pprint
##
##mx = 0  # Так как нам нужно время окончания выполнения процессов, ищем максимум
##for i in data:  # Проходим по всем значениям внутри словаря
##    f = calc(data, i)  # Ищем время поиска
##    mx = max(mx, f)  # Проверяем на максимум
##print('Result: {}'.format(mx))  # Вывод ответа


'''
27) (PRO100 ЕГЭ) В файле 22-27.xls содержится информация о совокупности N
вычислительных процессов, которые могут выполняться параллельно или
последовательно… (Условие совпадает с условием задачи из демо-варианта 2023
года).
'''
##def calc(data, i):
##    if '0' in data[i]['rel']:
##        return data[i]['time']
##    mx = 0
##    for search in data[i]['rel']:
##        f = calc(data, search)
##        mx = max(mx, f)
##    data[i]['rel'] = ['0']
##    data[i]['time'] += mx
##    return data[i]['time']
##
##with open('data/22-27.csv') as f:
##    rdr = [i for i in reader(f, delimiter=';', quotechar='"')]
##    data = {}
##    for i, time, rel, in rdr[1:]:
##        data[i] = {'time': int(time), 'rel': [x.strip() for x in rel.split(';')]}
##
##mx = 0
##for i in data:
##    f = calc(data, i)
##    mx = max(mx, f)
##print('Result: {}'.format(mx))


'''
29)	(PRO100 ЕГЭ) В файле 22-29.xls содержится информация о совокупности N
вычислительных процессов, которые могут выполняться параллельно или
последовательно. Будем говорить, что процесс B зависит от процесса A,
если для выполнения процесса B требуется, чтобы был выполнен хотя бы один из
процессов А. Информация о процессах представлена в файле в виде таблицы.
В первой строке таблицы указан идентификатор процесса (ID), во второй строке
таблицы – время его выполнения в миллисекундах, в третьей строке перечислены с
разделителем «;» ID процессов, от которых зависит данный процесс.
Если процесс является независимым, то в таблице указано значение 0.
Определите минимальное время, через которое завершится выполнение всей
совокупности процессов, при условии, что все независимые друг от друга
процессы могут выполняться параллельно.
В данном случае независимые процессы 1 и 2 могут выполняться параллельно,
при этом процесс 1 завершится через 4 мс, а процесс 2 – через 3 мс с момента
старта. Процесс 3 может начаться только после завершения процесса 1 или 2,
то есть, через 3 мс после старта. Он длится 1 мс и закончится через
3 + 1 = 4 мс после старта. Выполнение процесса 4 может начаться только после
завершения процесса 3, то есть, через 4 мс. Он длится 7 мс,
так что минимальное время завершения всех процессов равно 4 + 7 = 11 мс.
'''
##def calc(data, i):
##    if '0' in data[i]['rel']:
##        return data[i]['time']
##    mn = 10*10
##    for search in data[i]['rel']:
##        f = calc(data, search)
##        mn = min(mn, f)
##    data[i]['rel'] = ['0']
##    data[i]['time'] += mn
##    return data[i]['time']
##
##with open('data/22-29.csv') as f:
##    rdr = [i for i in reader(f, delimiter=';', quotechar='"')]
##    data = {}
##    for i, time, rel, in rdr[1:]:
##        data[i] = {'time': int(time), 'rel': [x.strip() for x in rel.split(';')]}
##
##mx = 0
##for i in data:
##    f = calc(data, i)
##    mx = max(mx, f)
##print('Result: {}'.format(mx))


'''
30)	(PRO100 ЕГЭ) В файле 22-30.xls содержится информация о совокупности N
вычислительных процессов, которые могут выполняться параллельно или
последовательно. Будем говорить, что процесс B зависит от процесса A,
если для выполнения процесса B требуется, чтобы был выполнен хотя бы 50%
от количества процессов А. Информация о процессах представлена в файле в
виде таблицы. В первой строке таблицы указан идентификатор процесса (ID),
во второй строке таблицы – время его выполнения в миллисекундах, в третьей
строке перечислены с разделителем «;» ID процессов, от которых зависит данный
процесс. Если процесс является независимым, то в таблице указано значение 0.
Определите минимальное время, через которое завершится выполнение всей
совокупности процессов, при условии, что все независимые друг от друга
процессы могут выполняться параллельно.
Типовой пример организации данных в файле:
ID процесса B	Время выполнения процесса B (мс)	ID процесса(ов) A
1	4	0
2	3	0
3	1	1; 2
4	7	1; 2; 3
В данном случае независимые процессы 1 и 2 могут выполняться параллельно,
при этом процесс 1 завершится через 4 мс, а процесс 2 – через 3 мс с момента
старта.  Процесс 3 может начаться только после завершения хотя бы 50% из двух
процессов, то есть любого процесса 1 или 2, то есть, через 3 мс после старта.
Он длится 1 мс и закончится через 3 + 1 = 4 мс после старта.
Выполнение процесса 4 может начаться только после завершения хотя бы 50% из
трёх процессов, то есть любых двух из процессов (1, 2, 3), то есть, через 4 мс.
Он длится 7 мс, так что минимальное время завершения всех процессов равно
4 + 7 = 11 мс.
'''
##def calc(data,i):
##    if '0' in data[i]['rel']:
##        return data[i]['time']
##    a = []
##    for search in data[i]['rel']:
##        f = calc(data,search)
##        a.append(f)
##    a.sort()
##    if not(len(a)%2):
##        mx = max(a[:len(a)//2])
##    else:
##        mx = max(a[:len(a)//2 + 1])
##    data[i]['rel'] = ['0']
##    data[i]['time'] += mx
##    return data[i]['time']
##
##with open('data/22-30.csv') as f:
##    rdr = [i for i in reader(f, delimiter=';', quotechar='"')]
##    data = {}
##    for i, time, rel, in rdr[1:]:
##        data[i] = {'time': int(time), 'rel': [x.strip() for x in rel.split(';')]}
##mx = 0
##for i in data:
##    f = calc(data,i)
##    mx = max(f,mx)
##print('Result: {}'.format(mx))


'''
31)	(А. Носкин) В файле 22-31.xls содержится информация о совокупности N
вычислительных процессов, которые могут выполняться параллельно или
последовательно. Будем говорить, что процесс B зависит от процесса A,
если для выполнения процесса B необходимы результаты выполнения процесса A.
Информация о процессах представлена в файле в виде таблицы. В первом столбце
таблицы указан идентификатор процесса (ID), во втором столбце таблицы – время
его выполнения в миллисекундах, в третьем столбце перечислены с
разделителем «;» ID процессов, от которых зависит данный процесс.
Если процесс является независимым, то в таблице указано значение 0.
При составлении таблицы была потеряна информация о том, после какого
процесса А начался процесс В с ID = 12. Однако известно, что вся совокупности
процессов завершилась за минимальное время 25 мс. Определите ID процесса,
после которого начался процесс с ID = 12. В ответе укажите только число.
Типовой пример организации данных в файле:
ID процесса B	Время выполнения процесса B (мс)	ID процесса(ов) A
1	4	0
2	3	0
3	1	1; 2
4	7	?
В данном случае независимые процессы 1 и 2 могут выполняться параллельно,
при этом процесс 1 завершится через 4 мс, а процесс 2 – через 3 мс с момента
старта. Процесс 3 может начаться только после завершения обоих процессов 1 и 2,
то есть, через 4 мс после старта. Он длится 1 мс и закончится через
4 + 1 = 5 мс после старта. Выполнение процесса 4 может начаться только после
завершения процесса, ID которого потеряно. Его продолжительность равно 7 мс.
Если бы минимальное время завершения всех процессов была равно 12 мс,
то процесс 4 начинался бы после процесса 3 (12 – 7 = 5мс).
'''
def calc(data, i):
    if '0' in data[i]['rel']:
        return data[i]['time']
    mx = 0
    for search in data[i]['rel']:
        f = calc(data, search)
        mx = max(mx, f)
    data[i]['rel'] = ['0']
    data[i]['time'] += mx
    return data[i]['time']

with open('data/22-31.csv') as f:
    rdr = [i for i in reader(f, delimiter=';', quotechar='"')]
    data = {}
    for i, time, rel, in rdr[1:]:
        data[i] = {'time': int(time), 'rel': [x.strip() for x in rel.split(';')]}


for i in range(1, 12):
    data['12']['rel'] = [str(i)]
    copy = {}
    for key in data:
        copy[key] = data[key].copy()
    
    mx = 0
    for j in copy:
        f = calc(copy, j)
        mx = max(mx, f)
    if mx == 25:
        print('Result: {}'.format(i))




'''↓ @VladPetrov3 ↓'''
##29

##from csv import reader
##f = open('22-29.csv')
##rdr = reader(f,delimiter=';', quotechar='"')
####delimiter - разделитель
####quotechar - склейка
####
####for s in rdr:
####    print(s)
##d={}
##def cal(d,id):
##    if '0' in d[id]['rel']:
##        return d[id]['time']
##    mx = 10**10
##    for searchID in d[id]['rel']:
##        t= cal(d,searchID)
##        mx = min(mx,t)
##    d[id]['rel'] = ['0']
##    d[id]['time'] +=mx
##    return d[id]['time']
##
##for id,time,rel  in rdr:
##    d[id]={'time': int(time), 'rel':[x.strip() for x in rel.split(';')]}
##mx= 0
##for id in d:
##    t = cal(d,id)
##    mx = max(t,mx)
##print(mx)


##30
##from csv import reader
##f = open('22-30.csv')
##rdr = reader(f,delimiter=';', quotechar='"')
####delimiter - разделитель
####quotechar - склейка
####
####for s in rdr:
####    print(s)
##d={}
##def cal(d,id):
##    if '0' in d[id]['rel']:
##        return d[id]['time']
##    a=[]
##    mx = 0
##    for searchID in d[id]['rel']:
##        t= cal(d,searchID)
##        a.append(t)
##    a.sort()
##
##    if len(a) % 2 ==0:
##        mx=max(a[:len(a)//2])
##    else:
##        mx = max(a[:len(a) //2  +1 ])
##    d[id]['rel'] = ['0']
##    d[id]['time'] +=mx
##    return d[id]['time']
##
##for id,time,rel  in rdr:
##    d[id]={'time': int(time), 'rel':[x.strip() for x in rel.split(';')]}
##mx= 0
##for id in d:
##    t = cal(d,id)
##    mx = max(t,mx)
##print(mx)

####31
##from csv import reader
##f = open('22-31.csv')
##rdr = reader(f,delimiter=';', quotechar='"')
####delimiter - разделитель
####quotechar - склейка
####
####for s in rdr:
####    print(s)
##d={}
##def cal(d,id):
##    if '0' in d[id]['rel']:
##        return d[id]['time']
##    a=[]
##    mx = 0
##    for searchID in d[id]['rel']:
##        t= cal(d,searchID)
##        mx = max(mx,t)
##    d[id]['rel'] = ['0']
##    d[id]['time'] +=mx
##    return d[id]['time']
##
##for id,time,rel  in rdr:
##    d[id]={'time': int(time), 'rel':[x.strip() for x in rel.split(';')]}
##mx= 0
##for i in range(1,12):
##    d['12']['time']=[str(i)]
##    copy={}
##    for key in d:
##        copy[key] = d[key].copy()
##    mx=0
##    for id in copy:
##        t = cal(copy,id)
##        mx = max(t,mx)
##    print(mx)
##    if mx == 25:
##        print(mx,i)



##32
##from csv import reader
##f = open('22-32.csv')
##rdr = reader(f,delimiter=';', quotechar='"')
####delimiter - разделитель
####quotechar - склейка
####
####for s in rdr:
####    print(s)
##d={}
##def cal(d,id):
##    if '0' in d[id]['rel']:
##        return d[id]['time']
##    a=[]
##    mx = 0
##    for searchID in d[id]['rel']:
##        t= cal(d,searchID)
##        mx = max(mx,t)
##    d[id]['rel'] = ['0']
##    d[id]['time'] +=mx
##    return d[id]['time']
##
##for id,time,rel,empty in rdr:
##    d[id]={'time': int(time), 'rel':[x.strip() for x in rel.split(';')]}
##
##mx= 0
##for i in range(1,150):
##    d['3']['time']=i
##    copy={}
##    for key in d:
##        copy[key] = d[key].copy()
##    mx=0
##    for id in copy:
##        t = cal(copy,id)
##        mx = max(t,mx)
##    
##    if mx == 134:
##        print(mx,i)

