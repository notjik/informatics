from time import time
from functools import lru_cache

start = time()
def timecomplite() -> None:
    print('\nThe program was completed in {} second!'.format(time() - start))
    return None


'''
1. (П. Финкель) В файле 17-204.txt содержится последовательность целых чисел, которые принимают
значения от -10000 до 10000 включительно. Тройка идущих подряд чисел последовательности
называется уникальной, если только второе из них является положительным числом,
заканчивающимся на 9. Определите количество уникальных троек чисел, а затем – максимальную из
всех сумм таких троек.
'''
##with open('data/17-204.txt') as f:
##    data = list(map(int, f.readlines()))
##c = 0
##mx = -30000
##for i in range(len(data) - 2):
##    if (data[i+1] > 0 and data[i+1] % 10 == 9) and not (data[i] > 0 and data[i] % 10 == 9) and \
##       not (data[i+2] > 0 and data[i+2] % 10 == 9):
##        c += 1
##        mx = max(mx, data[i] + data[i+1] + data[i+2])
##print(c, mx)
##timecomplite()


'''
2. (М. Шагитов) В файле 17-304.txt содержится последовательность целых чисел. Элементы
последовательности могут принимать целые значения от 0 до 10 000. Найдите все пары элементов
последовательности, в которых оба элемента пары в шестнадцатеричной записи имеют сочетание
цифр «AA», а сумма чисел пары меньше, чем максимальный элемент последовательности кратный
246. В ответе запишите количество найденных пар, затем максимальную из сумм элементов таких
пар. В данной задаче под парой подразумевается два идущих подряд элемента последовательности.
'''
##with open('data/17-304.txt') as f:
##    data = list(map(int, f.readlines()))
##m246 = max([i for i in data if not(i % 246)])
##c = 0
##mx = 0
##for i in range(len(data) - 1):
##    if 'aa' in hex(data[i])[2::] and 'aa' in hex(data[i+1])[2::] and data[i] + data[i+1] < m246:
##        c += 1
##        mx = max(mx, data[i] + data[i+1])
##print(c, mx)
##timecomplite()


'''
3. (Л. Шастин) В файле 17-10.txt содержится последовательность целых чисел. Элементы
последовательности могут принимать значения от 0 до 10000 включительно. Определите сначала
количество троек элементов последовательности, из которых можно составить прямоугольный
треугольник, а затем сумму всех гипотенуз треугольников в подходящих тройках. Под тройкой
подразумевается три идущих подряд элемента последовательности.
'''
##with open('data/17-10.txt') as f:
##    data = list(map(int, f.readlines()))
##res = [max(data[i:i+3]) for i in range(len(data) - 2) \
##       if sorted(data[i:i+3])[2]**2 == sorted(data[i:i+3])[0]**2 + sorted(data[i:i+3])[1]**2]
##print(len(res), sum(res))
##timecomplite()
        

'''
4. Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит куча камней. Игроки
ходят по очереди, первый ход делает Петя. За один ход игрок может
а) добавить в кучу один камень;
б) увеличить количество камней в куче в два раза.
Игра завершается в тот момент, когда количество камней в куче становится не менее 25. Если при
этом в куче оказалось не более 45 камней, то победителем считается игрок, сделавший последний
ход. В противном случае победителем становится его противник. В начальный момент в куче было S
камней, 1 ≤ S ≤ 24.
Ответьте на следующие вопросы:
Вопрос 1. Известно, что Ваня выиграл своим первым ходом после первого хода Пети. Назовите
минимальное значение S, при котором это возможно.
Вопрос 2. Определите два таких значения S, при которых у Пети есть выигрышная стратегия,
причём одновременно выполняются два условия:
− Петя не может выиграть за один ход;
− Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
Найденные значения запишите в ответе в порядке возрастания.
Вопрос 3. Найдите значение S, при которых одновременно выполняются два условия:
– у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при
любой игре Пети;
– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.
'''
##@lru_cache(None) 
##def game(x):
##    if x >= 25:
##        return 0
##    tmp = []
##    if x + 1 <= 45:
##        tmp.append(game(x+1))
##    if x * 2 <= 45:
##        tmp.append(game(x*2))
##    negative = [i for i in tmp if i <= 0]
##    if len(negative) != 0:
##        return -max(negative)+1
##    else:
##        return -max(tmp)
##
##print(*[i for i in range(1, 25) if game(i) == 2])
##print(*[i for i in range(1, 25) if game(i) == -2])
##timecomplite()


'''
5. (Е. Джобс) Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежат две кучи
камней. Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в одну
из куч (по своему выбору) два камня или увеличить количество камней в куче в два раза. Для того
чтобы делать ходы, у каждого игрока есть неограниченное количество камней. Игра завершается в тот
момент, когда суммарное количество камней в кучах становится не менее 231. Победителем считается
игрок, сделавший последний ход, т.е. первым получивший такую позицию, при которой в кучах будет
231 или больше камней.
В начальный момент в первой куче было 17 камней, во второй куче – S камней; 1 ≤ S ≤ 213.
Ответьте на следующие вопросы:
Вопрос 1. Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети.
Укажите максимальное значение S, когда такая ситуация возможна.
Вопрос 2. Найдите наибольшее и наименьшее значения S, при которых у Пети есть выигрышная
стратегия, причём одновременно выполняются два условия:
− Петя не может выиграть за один ход;
− Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
Найденные значения запишите в ответе в порядке возрастания.
Вопрос 3. Найдите минимальное значение S, при котором одновременно выполняются два условия:
– у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при
любой игре Пети;
– у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.
'''
##@lru_cache(None) 
##def game(x, y):
##    if x + y >= 231:
##        return 0
##    tmp = [game(x + 2, y), game(x, y + 2),
##           game(x * 2, y), game(x, y * 2)]
##    negative = [i for i in tmp if i <= 0]
##    if len(negative) != 0:
##        return -max(negative)+1
##    else:
##        return -max(tmp)
##
##res2 = [i for i in range(1, 214) if game(17, i) == 2]
##print(min(res2), max(res2))
##print(min([i for i in range(1, 214) if game(17, i) == -2]))
##timecomplite()


'''
6. (Е. Джобс) Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит куча
камней. Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может
а) добавить в кучу сто камней или
б) увеличить количество камней в куче в два раза.
Например, имея кучу из 10 камней, за один ход можно получить кучу из 110 или 20 камней. У
каждого игрока, чтобы делать ходы, есть неограниченное количество камней. Игра завершается в тот
момент, когда количество камней в куче становится не менее 1000. Победителем считается игрок,
сделавший последний ход, то есть первым получивший кучу, в которой будет 1000 или больше
камней.
В начальный момент в куче было S камней, 1 ≤ S ≤ 999.
Ответьте на следующие вопросы:
Вопрос 1. Сколько существует значений S, при которых Ваня выигрывает первым ходом?
Вопрос 2. Сколько существует значений S, при которых Петя может выиграть своим вторым ходом?
Вопрос 3. Назовите минимальное и максимальное значения S, при которых Ваня выигрывает своим
первым или вторым ходом, при этом для любого значения у Вани есть возможность выиграть своим
первым ходом (в случае ошибки Пети). Найденные значения запишите в ответе в порядке
возрастания.
'''
@lru_cache(None) 
def game(x):
    if x >= 1000:
        return 0
    tmp = [game(x+100), game(x*2)]
    negative = [i for i in tmp if i <= 0]
    if len(negative) != 0:
        return -max(negative)+1
    else:
        return -max(tmp)


print(len([i for i in range(1, 999) if game(i) == -1]))
print(len([i for i in range(1, 999) if game(i) == 2]))
res3 = [i for i in range(1, 999) if game(i) == -2]
print(res3)
timecomplite()
