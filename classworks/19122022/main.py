from time import time
from itertools import product
from functools import lru_cache

start = time()
def timecomplite() -> None:
    print('\nThe program was completed in {} second!'.format(time() - start))
    return None
    
'''
2. Логическая функция F задаётся выражением (a ∧ c) ∨ (¬a ∧ (b ∨ ¬c)).
Определите, какому столбцу таблицы истинности функции F соответствует
каждая из переменных a, b, c.
В ответе напишите буквы a, b, c в том порядке, в котором идут
соответствующие им столбцы (без разделителей).
'''
##print('c a b f')
##for c, a, b in product([0, 1], repeat=3):
##    f = int((a and c) or (not a and (b or not c)))
##    print(c, a, b, f)
##timecomplite()


'''
5. Автомат обрабатывает натуральное число N > 1 по следующему алгоритму:
1) Строится двоичная запись числа N.
2) В конец записи (справа) дописывается вторая справа цифра двоичной записи.
3) В конец записи (справа) дописывается вторая слева цифра двоичной записи.
4) Результат переводится в десятичную систему.
Пример. Дано число N = 11. Алгоритм работает следующим образом.
1) Двоичная запись числа N: 11 = 10112
2) Вторая справа цифра 1, новая запись 101112.
3) Вторая слева цифра 0, новая запись 1011102.
4) Десятичное значение полученного числа 46.
При каком наибольшем числе N в результате работы алгоритма получится число,
не превышающее 190? В ответе запишите это число в десятичной системе счисления.
'''
##for n in range(2, 1000):
##    r = bin(n)[2:]
##    r += r[-2]
##    r += r[1]
##    r = int(r, 2)
##    if r <= 190:
##        print(n)
##timecomplite()


'''
6. (А.Г. Минак) Определите, при каком наименьшем введённом значении переменной
s программа выведет число, не большее, чем 100.
'''
##for i in range(1, 1000):
##    s = i
##    n = 80
##    while s + n < 160:
##        s = s + 15
##        n = n - 10
##    if s <= 100:
##        print(i)
##        break
##timecomplite()


'''
8. Все 5-буквенные слова, составленные из букв Д, К, М, О, записаны в алфавитном порядке и
пронумерованы. Вот начало списка:
1. ДДДДД
2. ДДДДК
3. ДДДДМ
4. ДДДДО
5. ДДДКД
...
'''
##flag = False
##c = 0
##for i in product('ДКМО', repeat=5):
##    if ''.join(i) == 'ДОМОК':
##        flag = True
##    if flag:
##        c += 1
##    if ''.join(i) == 'КОМОД':
##        print(c)
##        break
##timecomplite()


'''
12. Исполнитель Редактор получает на вход строку цифр и преобразовывает её. Редактор может
выполнять две команды, в обеих командах v и w обозначают цепочки символов.
1. заменить (v, w)
2. нашлось (v)
Первая команда заменяет в строке первое слева вхождение цепочки v на цепочку w. Если цепочки v в
строке нет, эта команда не изменяет строку. Вторая команда проверяет, встречается ли цепочка v в
строке исполнителя Редактор.
Дана программа для исполнителя Редактор:
НАЧАЛО
ПОКА нашлось (555) ИЛИ нашлось (333)
ЕСЛИ нашлось (555)
ТО заменить (555, 3)
ИНАЧЕ заменить (333, 5)
КОНЕЦ ЕСЛИ
КОНЕЦ ПОКА
КОНЕЦ
Дана строка, состоящая из 400 цифр 5. Сколько троек было удалено за время обработки строки по
этой программе?
'''
##s = 400 * '5'
##d = 0
##while '555' in s or '333' in s:
##    if '555' in s:
##        s = s.replace('555', '3', 1)
##    else:
##        s = s.replace('333', '5', 1)
##        d += 3
##print(d)
##timecomplite()


'''
14. (М.В. Кузнецова) Значение арифметического выражения: 3260 + 4180 – 128 записали в системе
счисления с основанием 8. Сколько цифр «7» в этой записи?
'''
##print(oct(32**60 + 4**180 - 128)[2::].count('7'))
##timecomplite()


'''
16. Алгоритм вычисления значения функции F(n), где n – целое неотрицательное число, задан
следующими соотношениями:
F(n) = 0 при n = 0
F(n) = F(n/2) - 2 при чётных n > 0
F(n) = 2 + F(n–1) при нечётных n > 0
Сколько существует чисел n, меньших 1000, для которых значение F(n) будет равно -2?
'''
##def f(n):
##    if n == 0:
##        return 0
##    if not(n % 2):
##        return f(n//2) - 2
##    return 2 + f(n-1)
##
##c = 0
##for i in range(1, 1000):
##    if f(i) == -2:
##        c += 1
##print(c)
##timecomplite()


'''
17. В файле 17-1.txt содержится последовательность целых чисел. Элементы последовательности
могут принимать целые значения от –10 000 до 10 000 включительно. Определите количество троек, в
которых хотя бы один из трёх элементов больше, чем среднее арифметическое всех чисел в файле. В
ответе запишите два числа: сначала количество найденных троек, а затем – максимальную сумму
элементов таких троек. В данной задаче под тройкой подразумевается три идущих подряд элемента
последовательности.
'''
##with open('data/17-1.txt') as f:
##    data = list(map(int, f.readlines()))
##
##avg = sum(data) / len(data)
##c = 0
##mx = -30000
##
##for i in range(len(data)-2):
##    if data[i] > avg or data[i+1] > avg or data[i+2] > avg:
##        c += 1
##        mx = max(mx, data[i] + data[i+1] + data[i+2])
##print(c, mx)
##timecomplite()


'''
19. Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежат две кучи камней.
Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в одну из куч
один камень или увеличить количество камней в куче в два раза. Чтобы делать ходы, у каждого
игрока есть неограниченное количество камней. Игра завершается в тот момент, когда суммарное
количество камней в кучах становится не менее 87. Победителем считается игрок, сделавший
последний ход, т. е. первым получивший позицию, в которой в кучах будет 87 или больше камней.
В начальный момент в первой куче было 9 камней, во второй куче – S камней, 1 ≤ S ≤ 77. Будем
говорить, что игрок имеет выигрышную стратегию, если он может выиграть при любых ходах
противника.
Ответьте на следующие вопросы:
Вопрос 1. Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети.
Назовите минимальное значение S, при котором это возможно.
Вопрос 2. Найдите два таких значения S, при которых у Пети есть выигрышная стратегия, причём
Петя не может выиграть первым ходом, но может выиграть своим вторым ходом независимо от того,
как будет ходить Ваня. Найденные значения запишите в ответе в порядке возрастания.
Вопрос 3. Укажите минимальное значение S, при котором у Вани есть выигрышная стратегия,
позволяющая ему выиграть первым или вторым ходом при любой игре Пети, и при этом у Вани нет
стратегии, которая позволит ему гарантированно выиграть первым ходом.
'''
@lru_cache(None) 
def game(x, y):
    if x + y >= 87:
        return 0
    tmp = [game(x+1,y), game(x, y+1),
           game(x*2, y), game(x, y*2)]
    negative = [i for i in tmp if i <= 0]
    if len(negative) != 0:
        return -max(negative)+1
    else:
        return -max(tmp)


print(*[i for i in range(1, 77) if game(9, i) == 2])
print(min([i for i in range(1, 77) if game(9, i) == -2]))
timecomplite()
